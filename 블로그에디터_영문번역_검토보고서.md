# 블로그 에디터 영문 번역 기능 명세서 검토 보고서

**검토 일자**: 2025-12-13  
**검토 대상**: `블로그에디터_영문번역.md`  
**검토자**: AI Assistant

---

## ✅ 전체 평가

명세서는 **매우 상세하고 체계적으로 작성**되어 있으며, 구현 가능한 수준입니다. 특히 다음 부분이 우수합니다:

1. **명확한 UX 플로우**: 탭 기반 언어 전환, Empty State, 버튼 동작이 명확함
2. **구조 보존 번역 전략**: Tiptap JSON deep clone + 텍스트만 번역하는 접근이 안전함
3. **이미지 유지 전략**: EN에서 이미지 교체 후에도 유지되는 메커니즘이 잘 설계됨
4. **에러 처리**: mismatch 감지 및 fallback 전략이 구체적임

---

## 🔍 기술적 검토

### ✅ 현재 코드베이스와의 호환성

**완벽히 호환됨:**

1. **DB 스키마**: 
   - ✅ `canonical_id` 필드 존재 (마이그레이션 확인)
   - ✅ `locale` 필드 존재 ('ko' | 'en')
   - ✅ 트리거로 `canonical_id` 자동 설정됨
   - ✅ 인덱스 존재 (`uslab_idx_posts_canonical`)

2. **타입 정의**:
   - ✅ `UslabPost` 인터페이스에 `canonical_id`, `locale` 포함
   - ✅ `CreatePostData`, `UpdatePostData`에 해당 필드 포함

3. **기존 AI API 패턴**:
   - ✅ `/api/ai/slug` 구현 패턴 참고 가능
   - ✅ Gemini 2.0 Flash 사용 중
   - ✅ 인증 패턴 일관성 있음

### ⚠️ 주의사항 및 개선 제안

#### 1. **API 엔드포인트 경로**

**명세서**: `POST /api/ai/translate-post`

**제안**: 기존 패턴과 일관성을 위해 다음 중 선택:
- ✅ `/api/ai/translate-post` (명세서대로) - 권장
- 또는 `/api/posts/[id]/translate` (RESTful 패턴)

**결론**: 명세서대로 유지 권장

---

#### 2. **환경 변수 이름 불일치**

**명세서**: `GOOGLE_API_KEY` 언급

**현재 코드베이스**:
- `app/api/ai/generate/route.ts`: `GOOGLE_GENERATIVE_AI_API_KEY` 사용
- `app/api/ai/slug/route.ts`: `GOOGLE_GENERATIVE_AI_API_KEY` 사용
- 하지만 `generate/route.ts`에서 `GOOGLE_API_KEY`를 `GOOGLE_GENERATIVE_AI_API_KEY`로 매핑하는 코드 존재

**제안**: 명세서에 다음 추가:
```markdown
### 환경 변수
- `GOOGLE_API_KEY` 또는 `GOOGLE_GENERATIVE_AI_API_KEY` 사용 가능
- 코드에서 자동 매핑 처리됨
```

---

#### 3. **Tiptap JSON 구조 처리**

**명세서**: "텍스트 노드만 번역"이라고 명시

**주의사항 추가 필요**:
- Tiptap JSON은 중첩 구조가 복잡함
- `heading`, `paragraph`, `listItem` 등 다양한 노드 타입
- `marks` (bold, italic, link 등)가 있는 텍스트 노드 처리
- `codeBlock` 내부는 번역 제외 (명세서에 명시됨 ✅)

**제안**: `lib/translate/tiptapSegments.ts` 함수 시그니처 예시 추가

```typescript
// 명세서에 추가할 예시 코드
interface TextNodeRef {
  path: number[];  // JSON 경로 (예: [0, 'content', 0, 'text'])
  text: string;
  nodeType: string;  // 'heading' | 'paragraph' | 'listItem' | ...
  hasCodeMark?: boolean;  // inline code 마크가 있는지
}

function collectTranslatableTextNodes(
  doc: JSONContent,
  path: number[] = []
): TextNodeRef[] {
  // DFS로 순회하며 텍스트 노드 수집
  // codeBlock 내부, inline code 마크 제외
}
```

---

#### 4. **Update 전략의 "텍스트 노드 순서 매칭"**

**명세서**: "텍스트 노드 순서 기반 매칭" 제안

**잠재적 문제**:
- EN에서 이미지를 삭제/추가하면 텍스트 노드 순서가 바뀔 수 있음
- 예: KO에 이미지 3개, EN에 이미지 1개 → 텍스트 노드 순서가 달라질 수 있음

**개선 제안**:
1. **경로 기반 매칭 (더 안전)**:
   - KO와 EN의 JSON 구조를 비교
   - 같은 경로에 있는 텍스트 노드만 매칭
   - 구조가 다르면 경고 + rebase 추천

2. **하이브리드 접근**:
   - 먼저 경로 기반 매칭 시도
   - 실패 시 순서 기반 매칭 (fallback)
   - mismatch가 크면 409 에러

**명세서 수정 제안**:
```markdown
### 7.2 Update (EN 업데이트)

**text_only 업데이트 알고리즘(권장 v1): "경로 기반 매칭 + 순서 기반 fallback"**

1. source(KO)와 target(EN) content 로드
2. KO에서 번역 대상 세그먼트를 "JSON 경로(path)"와 함께 수집
3. EN에서도 같은 방식으로 수집
4. 매칭 전략:
   - **1차**: 경로 기반 매칭 (같은 경로의 텍스트 노드)
   - **2차**: 경로 매칭 실패 시 순서 기반 매칭 (index)
   - **3차**: mismatch가 크면 409 + rebase 안내
```

---

#### 5. **RLS 정책 확인**

**명세서**: 관리자 인증 필요 언급

**현재 상태**:
- ✅ `uslab_policy_posts_insert_authenticated` 존재
- ✅ `uslab_policy_posts_update_authenticated` 존재
- ⚠️ 하지만 authenticated 사용자가 draft를 조회할 수 있는 정책이 필요할 수 있음

**확인 필요**:
- 번역 API에서 EN row를 생성할 때 `is_published=false`로 생성
- 관리자가 EN 탭에서 draft를 볼 수 있어야 함
- 현재 RLS 정책이 이를 허용하는지 확인 필요

**제안**: 명세서에 RLS 정책 확인 섹션 추가

---

#### 6. **에러 처리 및 HTTP 상태 코드**

**명세서**: 409 언급 (mismatch 시)

**추가 필요**:
- 400: 잘못된 요청 (sourcePostId 없음, targetLocale 잘못됨)
- 401: 인증 실패
- 404: sourcePostId에 해당하는 포스트 없음
- 409: 구조 mismatch (rebase 필요)
- 500: Gemini API 오류, DB 오류

**제안**: 명세서에 에러 응답 예시 추가

```json
{
  "ok": false,
  "error": "Structure mismatch",
  "code": "STRUCTURE_MISMATCH",
  "details": "EN 텍스트 노드 수(45)와 KO 텍스트 노드 수(52)가 다릅니다. rebase_from_ko 전략을 사용하거나 EN 구조를 KO와 맞춰주세요.",
  "stats": {
    "koSegments": 52,
    "enSegments": 45,
    "mismatch": 7
  }
}
```

---

#### 7. **번역 품질 최적화**

**명세서**: temperature 0.2~0.35 권장 ✅

**추가 제안**:
- **용어 사전(Glossary)**: SOP, LLM, agent, USlab.ai 등은 번역하지 않고 그대로 유지
- **프롬프트 예시 추가**: 명세서에 실제 프롬프트 템플릿 예시 포함

```typescript
// 명세서에 추가할 프롬프트 예시
const systemPrompt = `You are a professional translator for a technical blog.
- Translate Korean to natural US English
- Maintain technical terms: SOP, LLM, agent, USlab.ai (do not translate)
- Keep code blocks, URLs, and inline code unchanged
- Return valid JSON only`;

const userPrompt = `Translate the following text segments while maintaining their IDs:

${segments.map(s => `ID: ${s.id}\nText: ${s.text}`).join('\n\n')}

Return JSON in this format:
{
  "translations": [
    { "id": "seg_1", "text_en": "translated text" },
    ...
  ]
}`;
```

---

#### 8. **성능 고려사항**

**명세서**: chunking 전략 언급 (120~200 세그먼트) ✅

**추가 고려사항**:
- **병렬 처리**: 여러 chunk를 동시에 번역 (Promise.all)
- **타임아웃**: Gemini API 호출 타임아웃 설정
- **재시도 로직**: 네트워크 오류 시 재시도 (exponential backoff)

**제안**: 명세서에 성능 최적화 섹션 추가

---

#### 9. **UI 컴포넌트 구조**

**명세서**: `PostVersionTabs.tsx`, `TranslateActions.tsx` 제안 ✅

**추가 제안**:
- **로딩 상태**: 번역 중 로딩 인디케이터
- **에러 모달**: 409 에러 시 rebase 옵션 제시
- **성공 피드백**: 번역 완료 후 토스트 메시지

---

#### 10. **테스트 시나리오**

**명세서**: Acceptance Criteria 있음 ✅

**추가 제안**:
- **엣지 케이스 테스트**:
  - KO에 이미지 없음
  - KO에 코드 블록만 있음
  - EN에서 모든 이미지 삭제 후 업데이트
  - 매우 긴 포스트 (1000+ 세그먼트)

---

## 📝 명세서 개선 제안 요약

### 필수 추가 사항

1. **환경 변수 명확화**: `GOOGLE_API_KEY` vs `GOOGLE_GENERATIVE_AI_API_KEY`
2. **에러 응답 스키마**: 모든 HTTP 상태 코드 및 응답 형식 정의
3. **RLS 정책 확인**: authenticated 사용자 draft 조회 가능 여부 확인
4. **경로 기반 매칭**: Update 전략에 경로 기반 매칭 추가

### 권장 추가 사항

5. **프롬프트 예시**: 실제 사용할 프롬프트 템플릿 코드
6. **용어 사전**: 번역하지 않을 용어 목록
7. **성능 최적화**: 병렬 처리, 타임아웃, 재시도 로직
8. **UI 상태 관리**: 로딩, 에러, 성공 피드백
9. **엣지 케이스**: 테스트 시나리오 확장

---

## ✅ 구현 우선순위 제안

### Phase 1 (핵심 기능)
1. ✅ Create (EN 최초 생성) - 이미지 복사 포함
2. ✅ 기본 Update (text_only) - 순서 기반 매칭
3. ✅ API 엔드포인트 (`/api/ai/translate-post`)
4. ✅ 기본 UI (탭, 버튼)

### Phase 2 (안정성)
5. 경로 기반 매칭 추가
6. 에러 처리 강화
7. 로딩/피드백 UI

### Phase 3 (최적화)
8. 병렬 처리
9. 용어 사전 적용
10. 성능 모니터링

---

## 🎯 최종 평가

**점수**: 9/10

**강점**:
- 명확한 UX 설계
- 안전한 번역 전략 (구조 보존)
- 이미지 유지 메커니즘
- 구체적인 구현 가이드

**개선 필요**:
- 에러 처리 상세화
- 경로 기반 매칭 추가
- 성능 최적화 고려

**결론**: 명세서는 **구현 가능한 수준**이며, 위 개선 사항들을 반영하면 더욱 견고한 구현이 가능합니다.

