현상만 보면 **“이미지 선택은 되는데( `ProseMirror-selectednode` 붙음) 리사이즈 UI만 전혀 생성되지 않는 상태”**라서, 제일 유력한 건 **ImageResize 플러그인의 `view()`가 아예 실행/등록되지 않은 케이스**예요. 실제로 명세서에도 “`view()` 훅이 실행되지 않음 / 플러그인이 제대로 등록되지 않음”을 가능 원인으로 적어두셨고 , BlogEditor 쪽에 `addProseMirrorPlugins()`로 붙인다고 되어있죠 .

아래는 **바로 고치는 “확정 루트(추천)”**입니다. 핵심은 2가지예요:

1. **ProseMirror Plugin을 “Tiptap Extension”으로 감싸서 extensions 배열에 확실히 등록**
2. **MutationObserver / DOM addEventListener 기반을 버리고, ProseMirror의 “선택 상태(NodeSelection) 업데이트”로 핸들을 띄우기**
   → 이렇게 하면 Novel/Tiptap이 클릭 이벤트를 가로채도(명세서의 원인 2 ) “선택 자체”는 바뀌기 때문에 리사이즈 핸들이 안정적으로 뜹니다. (명세서의 해결방안 1의 방향과 동일: `props.handleDOMEvents`/`update()` 활용 )

---

## 1) 1분 진단: 플러그인이 진짜 붙어있나?

`createImageResizePlugin()`의 `view()` 맨 위에 로그 1줄만 넣고 새로고침 해보세요.

```ts
view(view) {
  console.log('[ImageResize] view() mounted')
  ...
}
```

* 이 로그가 **안 찍히면** → 99% “등록이 안 됨”
* 로그가 **찍히는데도** 안 뜨면 → 그때는 핸들 DOM이 “ProseMirror 내부에 붙어서 지워지는” 등 구현 문제로 봐야 함

지금 증상(핸들/래퍼가 아예 생성 안 됨, 콘솔 에러 없음)  상으로는 전자(등록 문제) 쪽 확률이 높습니다.

---

## 2) 해결책 A: “플러그인 등록”을 확정으로 바꾸기 (필수)

Tiptap에서 `addProseMirrorPlugins()`는 **Extension 안에 있어야 확실히 먹습니다.**
BlogEditor 컴포넌트에 같은 이름의 함수를 만든다고 자동으로 연결되지 않아요(구조에 따라 무시될 수 있음).

### (1) Extension 래퍼 파일 추가

`components/editor/extensions/ImageResizeExtension.ts`

```ts
'use client'

import { Extension } from '@tiptap/core'
import { createImageResizePlugin } from '../ImageResizePlugin'

export const ImageResizeExtension = Extension.create({
  name: 'imageResizeExtension',
  addProseMirrorPlugins() {
    return [createImageResizePlugin()]
  },
})
```

### (2) BlogEditor의 extensions 배열에 추가

BlogEditor에서 extensions를 구성하는 곳(보통 `components/editor/extensions.tsx` 혹은 `BlogEditor.tsx`)에:

```ts
import { ImageResizeExtension } from '@/components/editor/extensions/ImageResizeExtension'

const extensions = [
  ...defaultExtensions,
  ImageResizeExtension,
]
```

이렇게만 해도 “플러그인 view() 자체가 안 도는 문제”는 대부분 끝납니다.

---

## 3) 해결책 B(추천): MutationObserver/DOM 클릭 감지 버리고 “선택 기반(update)”으로 구현

명세서 현재 구현은

* `view.dom.addEventListener('click', ...)` 
* `MutationObserver`로 selectednode 클래스 감지 

인데, 이 방식은 Novel/Tiptap 내부 플러그인과 충돌하거나(이벤트 소비) , DOM 변경 감지 타이밍 문제로 쉽게 깨져요.

그래서 **ProseMirror selection이 이미지(NodeSelection)로 바뀌는 순간**을 기준으로 핸들을 띄우는 게 정석입니다.

아래 코드는 “에디터 DOM(ProseMirror) 안”에 뭘 끼워 넣지 않고, **부모 컨테이너에 오버레이 핸들을 붙이는 방식**이라 안정적입니다.

### ImageResizePlugin 예시 코드 (교체용)

```ts
'use client'

import { Plugin, PluginKey, NodeSelection } from 'prosemirror-state'
import type { EditorView } from 'prosemirror-view'
import type { Node as ProseMirrorNode } from 'prosemirror-model'

const key = new PluginKey('uslab-image-resize')

const MIN = 50
const MAX = 1200
const HANDLE_SIZE = 12

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n))
}

function isImageNode(node: ProseMirrorNode | null | undefined) {
  if (!node) return false
  const name = (node.type?.name ?? '').toLowerCase()
  return name.includes('image') || !!node.attrs?.src
}

function getSelectedImage(view: EditorView): {
  pos: number
  node: ProseMirrorNode
  img: HTMLImageElement
} | null {
  const sel = view.state.selection
  if (!(sel instanceof NodeSelection)) return null
  if (!isImageNode(sel.node)) return null

  const pos = sel.from
  const dom = view.nodeDOM(pos) as unknown

  let img: HTMLImageElement | null = null
  if (dom instanceof HTMLImageElement) img = dom
  else if (dom instanceof HTMLElement) img = dom.querySelector('img')

  if (!img) return null
  return { pos, node: sel.node, img }
}

export function createImageResizePlugin() {
  return new Plugin({
    key,
    view(view) {
      const container = view.dom.parentElement
      if (!container) return {}

      // 오버레이용 positioning context 확보
      if (getComputedStyle(container).position === 'static') {
        container.style.position = 'relative'
      }

      // 핸들(오버레이) 생성: ProseMirror 내부가 아니라 "부모"에 붙임
      const handle = document.createElement('button')
      handle.type = 'button'
      handle.className = 'resizable-image-handle' // 기존 globals.css 클래스명에 맞추세요
      Object.assign(handle.style, {
        position: 'absolute',
        width: `${HANDLE_SIZE}px`,
        height: `${HANDLE_SIZE}px`,
        borderRadius: '9999px',
        cursor: 'nwse-resize',
        display: 'none',
        zIndex: '50',
      })
      container.appendChild(handle)

      let active:
        | { pos: number; node: ProseMirrorNode; img: HTMLImageElement }
        | null = null

      let dragging = false
      let startX = 0
      let startY = 0
      let startW = 0
      let startH = 0
      let aspect = 1

      const positionHandle = () => {
        if (!active) return
        const imgRect = active.img.getBoundingClientRect()
        const containerRect = container.getBoundingClientRect()

        const left =
          imgRect.right - containerRect.left + container.scrollLeft - HANDLE_SIZE / 2
        const top =
          imgRect.bottom - containerRect.top + container.scrollTop - HANDLE_SIZE / 2

        handle.style.left = `${left}px`
        handle.style.top = `${top}px`
      }

      const show = (next: NonNullable<typeof active>) => {
        active = next
        handle.style.display = 'block'
        positionHandle()
      }

      const hide = () => {
        active = null
        handle.style.display = 'none'
      }

      const onMouseMove = (e: MouseEvent) => {
        if (!dragging || !active) return

        const dx = e.clientX - startX
        const dy = e.clientY - startY

        let nextW = clamp(startW + dx, MIN, MAX)
        let nextH = clamp(startH + dy, MIN, MAX)

        // Shift: 비율 유지 (명세서 요구 :contentReference[oaicite:8]{index=8})
        if (e.shiftKey) {
          nextH = clamp(nextW / aspect, MIN, MAX)
        }

        active.img.style.width = `${Math.round(nextW)}px`
        active.img.style.height = `${Math.round(nextH)}px`
        positionHandle()
      }

      const onMouseUp = () => {
        if (!dragging || !active) return
        dragging = false

        window.removeEventListener('mousemove', onMouseMove)
        window.removeEventListener('mouseup', onMouseUp)

        // 최종 크기를 노드 attrs로 저장 (명세서의 의도 :contentReference[oaicite:9]{index=9})
        const width = parseInt(active.img.style.width, 10) || Math.round(startW)
        const height = parseInt(active.img.style.height, 10) || Math.round(startH)

        const { state } = view
        const nodeNow = state.doc.nodeAt(active.pos)
        if (!nodeNow) return

        const tr = state.tr.setNodeMarkup(active.pos, undefined, {
          ...nodeNow.attrs,
          width,
          height,
        })
        view.dispatch(tr)
      }

      const onMouseDown = (e: MouseEvent) => {
        if (!active) return
        e.preventDefault()
        e.stopPropagation()

        dragging = true
        startX = e.clientX
        startY = e.clientY

        const rect = active.img.getBoundingClientRect()
        startW = rect.width
        startH = rect.height
        aspect = startW / (startH || 1)

        window.addEventListener('mousemove', onMouseMove)
        window.addEventListener('mouseup', onMouseUp)
      }

      handle.addEventListener('mousedown', onMouseDown)

      const onReposition = () => {
        if (active) positionHandle()
      }
      container.addEventListener('scroll', onReposition)
      window.addEventListener('resize', onReposition)

      return {
        update(view) {
          const next = getSelectedImage(view)
          if (!next) {
            if (active) hide()
            return
          }

          if (!active || active.pos !== next.pos) {
            show(next)
          } else {
            positionHandle()
          }
        },
        destroy() {
          handle.removeEventListener('mousedown', onMouseDown)
          container.removeEventListener('scroll', onReposition)
          window.removeEventListener('resize', onReposition)
          window.removeEventListener('mousemove', onMouseMove)
          window.removeEventListener('mouseup', onMouseUp)
          handle.remove()
        },
      }
    },
  })
}
```

> 포인트
>
> * **핸들을 ProseMirror 안에 넣지 않음**(중요) → 에디터가 “내 DOM이 변했다”라고 판단해서 지우는 문제를 피합니다.
> * 클릭/Observer 없이도, 이미지가 선택(NodeSelection)되면 update가 반드시 돌기 때문에 안정적입니다. (명세서의 “클래스는 붙는데 핸들이 없다”  같은 상황을 회피)

---

## 4) CSS 체크 (최소)

명세서에 `globals.css`에 핸들 스타일이 있다고 되어 있으니 , 위 코드의 `className`을 거기에 맞추세요.

* 예: 기존이 `.resizable-handle`이면 `handle.className = 'resizable-handle'`
* 그리고 **핸들이 클릭 가능해야 하니** `pointer-events: auto;`가 필요할 수 있어요(부모에 `pointer-events: none` 같은 게 걸려있으면 핸들 클릭이 씹힙니다)

---

## 5) 그래도 불안하면 “정답 루트”: UpdatedImage NodeView로 통합

명세서에서 권장 해결방안으로도 적어둔 것처럼, Novel의 `UpdatedImage.extend()`에 `addNodeView()`로 통합하는 게 장기적으로 가장 안정적이에요 .
다만 지금은 “안 뜨는 문제”가 급하니, 위 **Extension 등록 + 선택 기반 plugin**으로 먼저 살리고, 나중에 NodeView로 리팩토링 하는 흐름이 가장 빠릅니다.

---

## 바로 확인할 테스트 3개 (딱 이것만)

명세서 테스트 시나리오에서 중요 포인트만 뽑으면 :

1. 이미지 클릭 → 핸들 표시
2. 핸들 드래그 → 실시간 크기 변경
3. 드래그 종료 → 새로고침 후 크기 유지

---

원하시면, 지금 운영진보드에서 쓰는 “이미지 노드 타입 이름(예: `image` vs `updatedImage`)”만 알려주시면(콘솔에서 `editor.state.selection.node.type.name`) 위 코드의 `isImageNode()` 조건을 프로젝트에 딱 맞게 더 타이트하게 맞춰드릴게요.
