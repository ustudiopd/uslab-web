# 히트맵 구현 방식 보고서

## 개요

본 문서는 USLab 웹사이트의 히트맵 기능 구현 방식을 상세히 설명합니다. 히트맵은 사용자의 클릭 패턴을 시각화하여 페이지의 어느 영역이 가장 많이 클릭되는지 분석할 수 있게 해줍니다.

## 기술 스택

### 사용된 라이브러리

**외부 라이브러리 없음** - 순수 웹 표준 기술만 사용:

- **HTML5 Canvas API**: 히트맵 시각화 렌더링
- **React Hooks**: 상태 관리 및 이펙트 처리
- **Next.js**: 서버 사이드 API 라우트
- **Supabase**: 데이터베이스 (PostgreSQL)
- **TypeScript**: 타입 안정성

### 왜 외부 라이브러리를 사용하지 않았나?

1. **경량화**: 외부 라이브러리 없이 순수 Canvas API로 구현하여 번들 크기 최소화
2. **커스터마이징**: 자체 구현으로 색상, 그리드 크기, 집계 방식 등을 완전히 제어 가능
3. **의존성 최소화**: 추가 패키지 설치 및 업데이트 관리 불필요

## 아키텍처 개요

```
사용자 클릭
    ↓
[Tracker.tsx] 클릭 이벤트 리스너
    ↓
[eventTracker.ts] trackClick() - 좌표 정규화
    ↓
[EventQueue] 배치 큐에 추가
    ↓
[POST /api/track] 이벤트 전송
    ↓
[uslab_events 테이블] 저장
    ↓
[GET /api/admin/heatmap/[pagePath]] 조회 및 그리드 집계
    ↓
[HeatmapViewer.tsx] 데이터 페칭
    ↓
[HeatmapOverlay.tsx] Canvas로 시각화
```

## 1. 데이터 수집 (Collection)

### 1.1 클릭 이벤트 리스너 등록

**파일**: `components/analytics/Tracker.tsx`

```typescript
useEffect(() => {
  if (!ANALYTICS_ENABLED) {
    return;
  }

  const handleClick = (event: MouseEvent) => {
    trackClick(
      event,
      currentPageViewIdRef.current,
      pathname
    );
  };

  // Capture phase로 리스너 등록 (모든 클릭 캡처)
  window.addEventListener('click', handleClick, true);

  return () => {
    window.removeEventListener('click', handleClick, true);
  };
}, [pathname]);
```

**특징**:
- **Capture phase (`true`)**: 이벤트 버블링 전에 모든 클릭을 캡처
- 페이지 경로(`pathname`) 변경 시 자동으로 리스너 재등록
- Analytics 비활성화 시 수집 중단

### 1.2 클릭 좌표 정규화 및 이벤트 생성

**파일**: `lib/utils/eventTracker.ts`

```typescript
export function trackClick(
  event: MouseEvent,
  pageViewId: string | null,
  pagePath: string
) {
  const target = event.target as HTMLElement;
  
  // 입력 요소 무시 (개인정보 보호)
  if (
    target.tagName === 'INPUT' ||
    target.tagName === 'TEXTAREA' ||
    target.isContentEditable
  ) {
    return;
  }

  // data-analytics-ignore 체크
  if (target.closest('[data-analytics-ignore]')) {
    return;
  }

  // 좌표 정규화 (0~1)
  const viewportW = window.innerWidth;
  const viewportH = window.innerHeight;
  const x = event.clientX / viewportW;  // 0~1 범위로 정규화
  const y = event.clientY / viewportH;  // 0~1 범위로 정규화

  // element_id 추출 (data-analytics-id 우선)
  const elementId = target.closest('[data-analytics-id]')?.getAttribute('data-analytics-id') || null;

  eventQueue.add({
    name: 'click',
    page_view_id: pageViewId,
    page_path: pagePath,
    props: {
      x,              // 정규화된 X 좌표 (0~1)
      y,              // 정규화된 Y 좌표 (0~1)
      viewport_w: viewportW,
      viewport_h: viewportH,
      element_id: elementId,
      element_tag: target.tagName.toLowerCase(),
      href_host: (target as HTMLAnchorElement).href 
        ? new URL((target as HTMLAnchorElement).href).hostname 
        : null,
    },
  });
}
```

**핵심 설계 결정**:

1. **좌표 정규화 (0~1)**: 
   - 뷰포트 크기에 상관없이 상대적 위치 저장
   - 다양한 디바이스/해상도에서 일관된 데이터 수집
   - 예: `x = 0.5, y = 0.3` → 화면 가로 중앙, 세로 30% 지점

2. **개인정보 보호**:
   - 입력 필드(`INPUT`, `TEXTAREA`) 클릭 무시
   - `data-analytics-ignore` 속성으로 특정 요소 제외 가능

3. **요소 식별**:
   - `data-analytics-id` 속성으로 중요한 요소에 안정적 ID 부여
   - 예: `<button data-analytics-id="cta-button">클릭</button>`

### 1.3 이벤트 큐 및 배치 전송

**파일**: `lib/utils/eventTracker.ts`

```typescript
class EventQueue {
  private queue: Event[] = [];
  private flushTimer: NodeJS.Timeout | null = null;
  private readonly FLUSH_SIZE = 10;      // 큐 크기 10개 도달 시 전송
  private readonly FLUSH_INTERVAL = 5000; // 5초마다 자동 전송

  add(event: Omit<Event, 'id' | 'client_ts'>) {
    // ... 샘플링 체크 ...
    
    this.queue.push(fullEvent);

    // 큐 크기 체크
    if (this.queue.length >= this.FLUSH_SIZE) {
      this.flush();
    } else if (!this.flushTimer) {
      // 타이머 시작
      this.flushTimer = setTimeout(() => {
        this.flush();
      }, this.FLUSH_INTERVAL);
    }
  }

  async flush() {
    if (this.queue.length === 0) {
      return;
    }

    const events = [...this.queue];
    this.queue = [];
    
    // sendBeacon으로 전송 (페이지 이탈 시에도 전송 보장)
    const blob = new Blob([JSON.stringify(payload)], {
      type: 'application/json',
    });

    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/track', blob);
    } else {
      fetch('/api/track', {
        method: 'POST',
        body: JSON.stringify(payload),
        keepalive: true,
        headers: {
          'Content-Type': 'application/json',
        },
      }).catch(() => {
        // 에러는 무시
      });
    }
  }
}
```

**최적화 전략**:

1. **배치 전송**: 
   - 개별 클릭마다 서버 요청하지 않음
   - 큐 크기 10개 또는 5초 간격으로 자동 전송
   - 네트워크 요청 수 최소화

2. **sendBeacon 사용**:
   - 페이지 이탈/닫힘 시에도 데이터 전송 보장
   - `keepalive: true` 옵션으로 안정성 확보

### 1.4 서버 사이드 저장

**파일**: `app/api/track/route.ts`

```typescript
// Events만 전송
const eventsTable = getAnalyticsTableName('events'); // 'uslab_events'
const eventsToInsert = events.map((event) => ({
  id: event.id,
  session_id: sessionId,
  page_view_id: event.page_view_id || null,
  name: event.name,              // 'click'
  page_path: event.page_path || '',
  props: event.props || {},      // { x, y, viewport_w, viewport_h, ... }
  client_ts: event.client_ts || null,
  created_at: new Date().toISOString(),
}));

const { error: eventsError } = await (supabase as any)
  .from(eventsTable)
  .insert(eventsToInsert);
```

**데이터베이스 스키마**:

**파일**: `supabase/migrations/20250116_create_uslab_events_table.sql`

```sql
create table if not exists uslab_events (
  id uuid primary key default gen_random_uuid(),
  session_id uuid not null references uslab_sessions(id) on delete cascade,
  page_view_id uuid references uslab_page_views(id) on delete set null,
  name text not null,                    -- 'click', 'scroll_depth', 'conversion', etc.
  page_path text not null,
  props jsonb not null default '{}',   -- { x: 0.5, y: 0.3, ... }
  client_ts bigint,                     -- 클라이언트 타임스탬프
  created_at timestamptz not null default now()
);

-- 인덱스
create index if not exists uslab_idx_events_page_path on uslab_events (page_path, created_at desc);
create index if not exists uslab_idx_events_name on uslab_events (name, created_at desc);
create index if not exists uslab_idx_events_session_id on uslab_events (session_id);
```

**저장되는 데이터 예시**:

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "session_id": "660e8400-e29b-41d4-a716-446655440001",
  "page_view_id": "770e8400-e29b-41d4-a716-446655440002",
  "name": "click",
  "page_path": "/ko",
  "props": {
    "x": 0.523,
    "y": 0.312,
    "viewport_w": 1920,
    "viewport_h": 1080,
    "element_id": "cta-button",
    "element_tag": "button",
    "href_host": null
  },
  "client_ts": 1704067200000,
  "created_at": "2025-01-01T00:00:00Z"
}
```

## 2. 데이터 조회 및 집계 (Aggregation)

### 2.1 API 엔드포인트

**파일**: `app/api/admin/heatmap/[pagePath]/route.ts`

```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ pagePath: string }> }
) {
  // 인증 확인 (관리자만 접근 가능)
  const authHeader = request.headers.get('authorization');
  // ... 인증 로직 ...

  const { pagePath } = await params;
  const decodedPagePath = decodeURIComponent(pagePath);
  
  // 쿼리 파라미터: days (기본값 30일)
  const days = parseInt(searchParams.get('days') || '30', 10);
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);

  // 해당 페이지의 클릭 이벤트 조회
  const { data: events } = await serverSupabase
    .from('uslab_events')
    .select('props')
    .eq('name', 'click')
    .eq('page_path', decodedPagePath)
    .gte('created_at', startDate.toISOString());

  // 그리드 집계 (20x20)
  const gridSize = 20;
  const gridMap = new Map<string, number>();

  events.forEach((event: any) => {
    const props = event.props || {};
    const x = props.x; // 0~1 정규화된 좌표
    const y = props.y; // 0~1 정규화된 좌표

    // 그리드 좌표 계산 (0~1을 0~gridSize로 변환)
    const gridX = Math.floor(x * gridSize);  // 0~19
    const gridY = Math.floor(y * gridSize); // 0~19
    const gridKey = `${gridX},${gridY}`;

    gridMap.set(gridKey, (gridMap.get(gridKey) || 0) + 1);
  });

  // 그리드를 객체로 변환
  const grid: Record<string, number> = {};
  gridMap.forEach((count, key) => {
    grid[key] = count;
  });

  return NextResponse.json({
    clicks: [...],      // 원본 클릭 좌표 배열 (디버깅용)
    grid: {             // 집계된 그리드 데이터
      "0,0": 5,
      "0,1": 3,
      "10,5": 15,
      // ...
    },
    stats: {
      totalClicks: 1234,
      uniqueElements: 45,
      gridSize: 20,
      dateRange: {
        start: "2025-01-01T00:00:00Z",
        end: "2025-01-31T23:59:59Z"
      }
    }
  });
}
```

**집계 로직 설명**:

1. **그리드 분할**: 
   - 페이지를 20x20 그리드로 분할 (총 400개 셀)
   - 정규화된 좌표(0~1)를 그리드 좌표(0~19)로 변환
   - 예: `x=0.523, y=0.312` → `gridX=10, gridY=6` → `"10,6"`

2. **집계**:
   - 각 그리드 셀에 속한 클릭 수를 카운트
   - `Map<string, number>`로 중복 제거 및 카운팅
   - 최종적으로 `Record<string, number>` 형태로 변환

3. **성능 최적화**:
   - 서버 사이드에서 집계하여 클라이언트로 전송되는 데이터 최소화
   - 원본 클릭 좌표는 디버깅용으로만 포함 (선택적)

## 3. 데이터 시각화 (Visualization)

### 3.1 데이터 페칭

**파일**: `components/admin/HeatmapViewer.tsx`

```typescript
export default function HeatmapViewer({ pagePath }: HeatmapViewerProps) {
  const searchParams = useSearchParams();
  const showHeatmap = searchParams.get('heatmap') === 'true';
  const [heatmapData, setHeatmapData] = useState<{
    grid: Record<string, number>;
    gridSize: number;
    totalClicks: number;
  } | null>(null);

  useEffect(() => {
    if (!showHeatmap) {
      setHeatmapData(null);
      return;
    }

    const fetchHeatmapData = async () => {
      // 관리자 인증 확인
      const { supabase } = await import('@/lib/supabase/client');
      const { data: { session } } = await supabase.auth.getSession();
      
      if (!session) {
        setError('인증이 필요합니다. 관리자로 로그인해주세요.');
        return;
      }

      // API 호출
      const encodedPath = encodeURIComponent(pagePath);
      const response = await fetch(`/api/admin/heatmap/${encodedPath}?days=30`, {
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      });

      const data = await response.json();
      setHeatmapData({
        grid: data.grid || {},
        gridSize: data.stats?.gridSize || 20,
        totalClicks: data.stats?.totalClicks || 0,
      });
    };

    fetchHeatmapData();
  }, [showHeatmap, pagePath]);

  // ...
}
```

**활성화 방식**:
- URL 쿼리 파라미터 `?heatmap=true`로 히트맵 모드 활성화
- 예: `https://uslab.ai/ko?heatmap=true`

### 3.2 Canvas 기반 히트맵 렌더링

**파일**: `components/admin/HeatmapOverlay.tsx`

#### 3.2.1 전체 문서 크기 추적

```typescript
const [docSize, setDocSize] = useState({ width: 0, height: 0 });

useEffect(() => {
  const updateDocSize = () => {
    const width = Math.max(
      document.documentElement.scrollWidth,
      document.body.scrollWidth,
      window.innerWidth
    );
    const height = Math.max(
      document.documentElement.scrollHeight,
      document.body.scrollHeight,
      window.innerHeight
    );
    setDocSize({ width, height });
  };

  updateDocSize();
  window.addEventListener('resize', updateDocSize);
  window.addEventListener('scroll', updateDocSize);
  
  // DOM 변경 감지 (동적 콘텐츠 로드 시)
  const resizeObserver = new ResizeObserver(updateDocSize);
  resizeObserver.observe(document.body);
  resizeObserver.observe(document.documentElement);

  return () => {
    window.removeEventListener('resize', updateDocSize);
    window.removeEventListener('scroll', updateDocSize);
    resizeObserver.disconnect();
  };
}, []);
```

**왜 전체 문서 크기를 추적하나?**
- 페이지가 스크롤 가능한 긴 문서인 경우, 뷰포트 크기만으로는 부족
- 스크롤 위치와 관계없이 전체 페이지에 히트맵을 정확히 표시하기 위함

#### 3.2.2 Canvas 그리기

```typescript
useEffect(() => {
  const canvas = canvasRef.current;
  if (!canvas || docSize.width === 0 || docSize.height === 0) return;

  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  // 캔버스 크기를 전체 문서 크기에 맞춤
  canvas.width = docSize.width;
  canvas.height = docSize.height;

  // 캔버스 초기화
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 그리드 셀 크기 계산 (전체 문서 기준)
  const cellWidth = canvas.width / gridSize;   // 예: 1920 / 20 = 96px
  const cellHeight = canvas.height / gridSize; // 예: 5000 / 20 = 250px

  // 각 그리드 셀에 색상 적용
  Object.entries(grid).forEach(([key, clicks]) => {
    const [gridX, gridY] = key.split(',').map(Number);
    const x = gridX * cellWidth;   // 픽셀 좌표로 변환
    const y = gridY * cellHeight;  // 픽셀 좌표로 변환

    // 클릭 수에 따른 색상 강도 계산 (0~1)
    const intensity = Math.min(clicks / maxClicks, 1);

    // 색상 그라데이션 계산
    let r, g, b, a;
    if (intensity < 0.25) {
      // 파란색 (낮음)
      // ...
    } else if (intensity < 0.5) {
      // 녹색 (중간)
      // ...
    } else if (intensity < 0.75) {
      // 노란색 (높음)
      // ...
    } else {
      // 빨간색 (매우 높음)
      // ...
    }

    // 그리드 셀에 색상 적용
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
    ctx.fillRect(x, y, cellWidth, cellHeight);
  });
}, [grid, gridSize, maxClicks, docSize]);
```

**색상 그라데이션**:

| 강도 범위 | 색상 | 투명도 | 의미 |
|---------|------|--------|------|
| 0.0 ~ 0.25 | 파란색 | 0.0 ~ 0.3 | 낮음 |
| 0.25 ~ 0.5 | 녹색 | 0.3 ~ 0.5 | 중간 |
| 0.5 ~ 0.75 | 노란색 | 0.5 ~ 0.7 | 높음 |
| 0.75 ~ 1.0 | 빨간색 | 0.7 ~ 1.0 | 매우 높음 |

**렌더링 최적화**:
- `fillRect()`로 각 그리드 셀을 한 번에 그리기 (400개 셀 이하)
- Canvas 2D Context의 하드웨어 가속 활용
- `pointer-events: none`으로 클릭 이벤트 차단 (페이지 상호작용 방해 없음)

#### 3.2.3 오버레이 구조

```typescript
return (
  <>
    {/* 히트맵 오버레이 컨테이너 - 전체 문서 크기로 설정 */}
    <div
      ref={containerRef}
      className="fixed top-0 left-0 z-50 pointer-events-none"
      style={{
        width: `${docSize.width}px`,
        height: `${docSize.height}px`,
      }}
    >
      {/* 히트맵 캔버스 */}
      <canvas
        ref={canvasRef}
        className="absolute top-0 left-0"
        style={{ 
          pointerEvents: 'none',
          width: `${docSize.width}px`,
          height: `${docSize.height}px`,
        }}
      />
    </div>

    {/* 컨트롤 패널 - 뷰포트에 고정 */}
    <div className="fixed top-4 right-4 z-[60] bg-white/95 backdrop-blur-sm border border-slate-300 rounded-lg p-4 shadow-lg pointer-events-auto">
      {/* 범례 및 통계 */}
    </div>
  </>
);
```

**레이어 구조**:
- **히트맵 컨테이너**: `fixed` 포지션, 전체 문서 크기, `z-index: 50`
- **캔버스**: `absolute` 포지션, `pointer-events: none`
- **컨트롤 패널**: `fixed` 포지션, 뷰포트 고정, `z-index: 60`, `pointer-events: auto`

## 4. 데이터 플로우 요약

### 4.1 수집 플로우

```
1. 사용자가 페이지에서 클릭
   ↓
2. Tracker.tsx의 handleClick() 실행
   ↓
3. eventTracker.ts의 trackClick() 호출
   - 좌표 정규화 (0~1)
   - 입력 필드 필터링
   - data-analytics-ignore 체크
   ↓
4. EventQueue.add()로 큐에 추가
   ↓
5. 큐 크기 10개 도달 또는 5초 경과 시
   ↓
6. EventQueue.flush()로 배치 전송
   - sendBeacon 또는 fetch(keepalive) 사용
   ↓
7. POST /api/track 엔드포인트 수신
   ↓
8. uslab_events 테이블에 저장
   - session_id, page_path, props (x, y, ...) 저장
```

### 4.2 시각화 플로우

```
1. 관리자가 대시보드에서 "메인페이지 히트맵 보기" 클릭
   ↓
2. URL에 ?heatmap=true 추가
   ↓
3. HeatmapViewer.tsx가 쿼리 파라미터 감지
   ↓
4. GET /api/admin/heatmap/[pagePath] 호출
   - 인증 토큰 포함
   - days 파라미터 (기본 30일)
   ↓
5. 서버에서 클릭 이벤트 조회 및 그리드 집계
   - uslab_events에서 name='click' 조회
   - page_path 필터링
   - 날짜 범위 필터링
   - 20x20 그리드로 집계
   ↓
6. 클라이언트로 그리드 데이터 반환
   ↓
7. HeatmapOverlay.tsx가 Canvas로 렌더링
   - 전체 문서 크기 계산
   - 그리드 셀을 픽셀 좌표로 변환
   - 클릭 수에 따른 색상 적용
   - Canvas에 그리기
```

## 5. 성능 고려사항

### 5.1 클라이언트 사이드

- **배치 전송**: 개별 클릭마다 서버 요청하지 않음
- **sendBeacon**: 페이지 이탈 시에도 데이터 전송 보장
- **Canvas 렌더링**: DOM 조작 없이 Canvas API로 빠른 렌더링
- **ResizeObserver**: DOM 변경 시에만 리렌더링

### 5.2 서버 사이드

- **인덱스 활용**: `page_path`, `name`, `created_at` 인덱스로 빠른 조회
- **서버 사이드 집계**: 클라이언트로 전송되는 데이터 최소화
- **그리드 집계**: 원본 좌표 대신 집계된 그리드 데이터만 전송

### 5.3 데이터베이스

- **JSONB 타입**: `props` 필드를 JSONB로 저장하여 유연한 스키마
- **인덱스 최적화**: 자주 조회되는 필드에 인덱스 생성
- **Cascade 삭제**: 세션 삭제 시 관련 이벤트 자동 삭제

## 6. 확장 가능성

### 6.1 현재 제한사항

- 그리드 크기 고정 (20x20)
- 색상 그라데이션 고정
- 단일 페이지 히트맵만 지원

### 6.2 향후 개선 가능 사항

1. **동적 그리드 크기**: 페이지 크기에 따라 그리드 크기 조정
2. **시간대별 히트맵**: 시간대별로 다른 색상 표시
3. **디바이스별 히트맵**: 모바일/데스크톱 분리 표시
4. **애니메이션**: 클릭 수 변화를 애니메이션으로 표시
5. **인터랙티브**: 특정 그리드 셀 클릭 시 상세 정보 표시

## 7. 보안 및 개인정보 보호

### 7.1 데이터 수집 시

- 입력 필드 클릭 무시
- `data-analytics-ignore` 속성으로 특정 요소 제외 가능
- 좌표만 저장 (텍스트 내용 저장 안 함)

### 7.2 데이터 조회 시

- 관리자 인증 필수 (`Authorization` 헤더)
- RLS (Row Level Security) 정책으로 데이터 접근 제한

### 7.3 개인정보 보호

- 개인 식별 가능한 정보 수집 안 함
- 세션 ID만 저장 (사용자 ID 아님)
- 좌표는 정규화된 상대값만 저장

## 8. 결론

USLab의 히트맵 기능은 외부 라이브러리 없이 순수 웹 표준 기술로 구현되었습니다. 이는 다음과 같은 장점을 제공합니다:

1. **경량화**: 번들 크기 최소화
2. **커스터마이징**: 완전한 제어 가능
3. **성능**: 효율적인 배치 전송 및 Canvas 렌더링
4. **확장성**: 유연한 데이터 구조로 향후 기능 추가 용이

데이터 수집부터 시각화까지의 전체 플로우가 최적화되어 있으며, 개인정보 보호와 성능을 모두 고려한 설계입니다.

