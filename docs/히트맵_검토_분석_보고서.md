# 히트맵 검토 문서 분석 보고서

## 개요

본 문서는 `히트맵검토.md`에서 제시된 문제점과 개선 방안을 현재 구현과 비교 분석한 결과입니다.

## 1. 현재 구현 상태 확인

### 1.1 좌표 수집 방식 (검토 문서의 문제점 A 확인)

**현재 구현** (`lib/utils/eventTracker.ts`):

```typescript
// 좌표 정규화 (0~1)
const viewportW = window.innerWidth;
const viewportH = window.innerHeight;
const x = event.clientX / viewportW;  // 뷰포트 기준
const y = event.clientY / viewportH;  // 뷰포트 기준
```

**검토 문서 지적사항**: ✅ **정확히 지적됨**

- 현재는 `clientX / innerWidth`, `clientY / innerHeight`로 저장
- 스크롤 위치(`scrollX`, `scrollY`)가 포함되지 않음
- 결과적으로 스크롤한 상태에서 클릭하면 `y`가 다시 0~1로 들어감
- 렌더링은 문서 전체 높이(`scrollHeight`) 기준인데, 좌표는 뷰포트 기준이라 **위치 불일치 발생**

**영향도**: 🔴 **높음** - 긴 페이지에서 히트맵 위치가 부정확함

### 1.2 렌더링 방식 (검토 문서의 문제점 B 확인)

**현재 구현** (`components/admin/HeatmapOverlay.tsx`):

```typescript
// 20x20 그리드로 집계
const gridSize = 20;
const cellWidth = canvas.width / gridSize;
const cellHeight = canvas.height / gridSize;

// 각 그리드 셀을 네모로 칠하기
ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
ctx.fillRect(x, y, cellWidth, cellHeight);
```

**검토 문서 지적사항**: ✅ **정확히 지적됨**

- 현재는 `fillRect`로 각 셀을 네모로 칠함
- 블러(blur)나 반경(radius) 없이 단순 사각형 렌더링
- 결과적으로 "격자 느낌"이 강함
- 상용 히트맵의 부드러운 Blob 느낌이 없음

**영향도**: 🟡 **중간** - 시각적 품질 문제 (기능적으로는 동작함)

### 1.3 캔버스 크기 (검토 문서의 성능 이슈 확인)

**현재 구현**:

```typescript
// 전체 문서 크기로 캔버스 생성
canvas.width = docSize.width;   // 예: 1920px
canvas.height = docSize.height; // 예: 5000px (긴 페이지)
```

**검토 문서 지적사항**: ✅ **정확히 지적됨**

- 문서 높이만큼 캔버스를 크게 만듦
- 긴 페이지(예: 5000px)에서 캔버스 픽셀 수가 폭증 (1920 × 5000 = 9,600,000 픽셀)
- 메모리/CPU 사용량 증가

**영향도**: 🟡 **중간** - 긴 페이지에서만 문제 (일반적인 페이지에서는 괜찮음)

## 2. 검토 문서 제안사항 분석

### 2.1 좌표 수집 개선안 평가

**제안**: 문서 기준 좌표 추가
- `page_x`: `(clientX + scrollX) / docWidth`
- `page_y`: `(clientY + scrollY) / docHeight`
- `doc_w`, `doc_h`: 클릭 당시 문서 크기
- `scroll_x`, `scroll_y`: 클릭 당시 스크롤 위치

**평가**: ✅ **매우 합리적**

**장점**:
1. 스크롤 위치를 포함하여 정확한 페이지 위치 저장
2. 기존 `x`, `y` 필드와 호환 (하위 호환성 유지)
3. JSONB 구조라 DB 마이그레이션 불필요
4. 요소 기준 좌표(`element_x`, `element_y`)도 함께 저장하면 반응형 대응 가능

**구현 난이도**: 🟢 **낮음** - `trackClick` 함수만 수정하면 됨

**권장사항**: ✅ **즉시 적용 권장**

### 2.2 요소 기준 좌표 저장 평가

**제안**: 
- `element_x`, `element_y`: 요소 내부 좌표(0~1)
- `element_w`, `element_h`: 요소 크기

**평가**: ✅ **장기적으로 유용**

**장점**:
- 레이아웃 변경 시에도 히트맵이 요소에 붙어서 표시 가능
- 반응형 디자인에서 유용

**단점**:
- 구현 복잡도 증가
- 모든 클릭에 대해 요소 위치 계산 필요 (성능 영향 미미)

**구현 난이도**: 🟡 **중간** - 요소 위치 계산 로직 필요

**권장사항**: 🟡 **Phase 2에서 적용** (우선순위 낮음)

### 2.3 그리드 해상도 개선 평가

**제안**: 20×20 → 200×200 또는 300×300

**평가**: ✅ **시각적 품질 향상에 필수**

**현재 문제**:
- 20×20 = 400개 셀 → 너무 거침
- 예: 1920px 페이지에서 셀 크기 = 96px (너무 큼)

**개선 후**:
- 200×200 = 40,000개 셀 → 훨씬 세밀함
- 예: 1920px 페이지에서 셀 크기 = 9.6px (적절함)

**성능 고려사항**:
- 서버 집계: 200×200도 충분히 빠름 (단순 카운팅)
- 클라이언트 렌더링: Blob 렌더링과 함께 사용하면 부드러움

**구현 난이도**: 🟢 **낮음** - `gridSize` 상수만 변경

**권장사항**: ✅ **즉시 적용 권장** (Blob 렌더링과 함께)

### 2.4 Blob 렌더링 (KDE) 평가

**제안**: heatmap.js 스타일 알고리즘
1. Shadow canvas에 검정색 + blur circle로 누적
2. Alpha 값을 읽어서 팔레트로 색칠(colorize)
3. 실제 canvas에 출력

**평가**: ✅ **상용 히트맵 느낌의 핵심**

**현재 방식 vs Blob 방식**:

| 항목 | 현재 (fillRect) | Blob (KDE) |
|------|----------------|------------|
| 시각적 품질 | 격자 느낌 | 부드러운 덩어리 |
| 구현 복잡도 | 낮음 | 중간 |
| 성능 | 빠름 | 보통 (blur 연산) |
| 사용자 체감 | MVP 수준 | 상용 수준 |

**구현 난이도**: 🟡 **중간** - Canvas 2D API로 구현 가능

**성능 최적화**:
- Shadow canvas는 뷰포트 크기만 사용 (전체 문서 아님)
- Blur는 `ctx.filter = 'blur(20px)'` 사용 (하드웨어 가속)
- Colorize는 `getImageData` + `putImageData`로 구현

**권장사항**: ✅ **핵심 개선사항, 우선 적용**

### 2.5 뷰포트 캔버스 + 스크롤 변환 평가

**제안**: 
- 캔버스는 뷰포트 크기만 유지 (`100vw × 100vh`)
- 렌더링 시 `page_x/y → 현재 스크롤 기준 화면 좌표`로 변환

**평가**: ✅ **성능 최적화에 매우 효과적**

**현재 방식**:
- 캔버스: 1920 × 5000px = 9,600,000 픽셀
- 메모리: 약 38MB (RGBA)

**개선 후**:
- 캔버스: 1920 × 1080px = 2,073,600 픽셀
- 메모리: 약 8MB (RGBA)
- **메모리 사용량 약 78% 감소**

**구현 난이도**: 🟡 **중간** - 스크롤 이벤트 처리 및 좌표 변환 필요

**주의사항**:
- 스크롤 시 히트맵 재렌더링 필요 (성능 영향 고려)
- Debounce/Throttle 적용 권장

**권장사항**: ✅ **성능 개선에 필수, Phase 1에서 적용**

### 2.6 컨트롤 패널 확장 평가

**제안**: radius, blur, opacity, gradient preset 조절

**평가**: ✅ **UX 개선에 유용**

**장점**:
- 사용자가 히트맵 가독성을 직접 조절 가능
- 다양한 페이지 레이아웃에 대응 가능

**구현 난이도**: 🟢 **낮음** - UI 컴포넌트 추가

**권장사항**: 🟡 **Phase 2에서 적용** (우선순위 낮음)

## 3. 추가 기능 제안 평가

### 3.1 Dead Click / Rage Click 추정

**평가**: ✅ **AI 분석에 매우 유용**

**현재 데이터로 가능한지**:
- ✅ `href_host`, `element_tag` 이미 수집 중
- ✅ `client_ts` 저장 가능 (현재는 optional)
- ✅ `session_id`로 세션별 분석 가능

**구현 방법**:
- Dead Click: `href_host=null` + `element_tag`가 button/a가 아닌 영역
- Rage Click: 같은 `session_id` + `page_path`에서 짧은 시간(2초) 내 비슷한 좌표 반복

**구현 난이도**: 🟡 **중간** - 집계 쿼리 작성 필요

**권장사항**: ✅ **AI 보고서 연동 시 매우 유용, Phase 2 적용**

### 3.2 디바이스별 히트맵 분리

**평가**: ✅ **필수 기능**

**현재 데이터**:
- ✅ `device_type`이 `uslab_sessions` 테이블에 있음
- ✅ `viewport_w`, `viewport_h`가 클릭 이벤트 `props`에 있음

**구현 방법**:
- API에서 `device_type` 또는 `viewport_w` 기준 필터링
- UI에서 디바이스 선택 드롭다운 추가

**구현 난이도**: 🟢 **낮음** - 필터링 로직만 추가

**권장사항**: ✅ **즉시 적용 권장** (데이터 이미 있음)

### 3.3 스크롤맵 (Scroll Map)

**평가**: ✅ **세션녹화 대안으로 매우 유용**

**현재 데이터**:
- ✅ `scroll_depth` 이벤트 이미 수집 중
- ✅ `page_engagement` 이벤트도 있음

**구현 방법**:
- 스크롤 깊이 데이터를 히트맵과 유사하게 시각화
- 페이지 세로축을 따라 색상 그라데이션 (위→아래: 밝음→어두움)

**구현 난이도**: 🟡 **중간** - 새로운 시각화 컴포넌트 필요

**권장사항**: 🟡 **Phase 2에서 적용** (별도 기능)

## 4. AI 기능 연동 평가

**제안**: 구조화된 요약값을 AI 입력으로 제공

**평가**: ✅ **매우 효율적**

**제안된 스키마**:
- `total_clicks`
- `top_hotspots`: (x, y, count) 상위 5~10개
- `top_elements`: `data-analytics-id` 상위 10개
- `dead_click_zones`: dead click 추정 hotspot 상위 5개
- `rage_click_elements`: rage click 의심 element 상위 5개
- `click_concentration`: 상위 10% 영역이 전체 클릭의 몇 %를 차지하는지

**현재 AI 보고서 구조**:
- `lib/utils/reportFormatter.ts`에서 데이터 포맷팅
- 히트맵 데이터는 아직 포함되지 않음

**구현 방법**:
1. 히트맵 집계 API에 요약 지표 추가
2. `reportFormatter.ts`에 히트맵 요약 데이터 포함
3. AI 프롬프트에 히트맵 인사이트 추가

**구현 난이도**: 🟡 **중간** - 집계 로직 및 프롬프트 수정

**권장사항**: ✅ **AI 보고서 품질 향상에 필수, Phase 2 적용**

## 5. 적용 우선순위 재검토

검토 문서의 우선순위를 현재 구현 상태와 비교하여 재평가:

### Phase 1: 즉시 적용 (체감 업그레이드 큰 순서)

1. ✅ **좌표를 page 기준으로 확장** (`page_x/page_y`, `doc_w/doc_h`, `scroll_y`)
   - **이유**: 위치 정확도 문제 해결 (핵심 버그)
   - **구현 난이도**: 🟢 낮음
   - **영향도**: 🔴 높음

2. ✅ **뷰포트 캔버스 + scroll offset 렌더**로 정렬 문제 해결
   - **이유**: 성능 최적화 + 위치 정확도
   - **구현 난이도**: 🟡 중간
   - **영향도**: 🟡 중간

3. ✅ **20×20 → 200×200 bin + Blob 렌더링**
   - **이유**: 시각적 품질 향상 (상용 수준)
   - **구현 난이도**: 🟡 중간
   - **영향도**: 🟡 중간

4. ✅ **디바이스 필터** (desktop/mobile)
   - **이유**: 데이터 이미 있음, 구현 간단
   - **구현 난이도**: 🟢 낮음
   - **영향도**: 🟡 중간

### Phase 2: 중기 개선 (AI 연동 및 고급 기능)

5. 🟡 **Dead/Rage click 요약 + AI 보고서에 포함**
   - **이유**: AI 분석 품질 향상
   - **구현 난이도**: 🟡 중간
   - **영향도**: 🟡 중간

6. 🟡 **요소 기준 좌표 저장** (`element_x/element_y`)
   - **이유**: 반응형 대응 (장기적)
   - **구현 난이도**: 🟡 중간
   - **영향도**: 🟢 낮음

7. 🟡 **컨트롤 패널 확장** (radius/blur/opacity 조절)
   - **이유**: UX 개선 (선택적)
   - **구현 난이도**: 🟢 낮음
   - **영향도**: 🟢 낮음

8. 🟡 **스크롤맵** (Scroll Map)
   - **이유**: 별도 기능 (세션녹화 대안)
   - **구현 난이도**: 🟡 중간
   - **영향도**: 🟡 중간

## 6. 구현 복잡도 및 리스크 분석

### 6.1 낮은 리스크 (즉시 적용 가능)

- ✅ 좌표 page 기준 확장
- ✅ 디바이스 필터
- ✅ 그리드 해상도 증가 (200×200)

**예상 작업 시간**: 2-4시간

### 6.2 중간 리스크 (테스트 필요)

- 🟡 뷰포트 캔버스 + 스크롤 변환
- 🟡 Blob 렌더링 (KDE)

**예상 작업 시간**: 4-8시간

**주의사항**:
- 스크롤 성능 테스트 필수
- 다양한 페이지 높이에서 테스트 필요
- 브라우저 호환성 확인 (Canvas API)

### 6.3 높은 리스크 (신중한 접근 필요)

- 🔴 요소 기준 좌표 저장 (모든 클릭에 요소 위치 계산)
- 🔴 Dead/Rage click 집계 (복잡한 쿼리)

**예상 작업 시간**: 8-16시간

**주의사항**:
- 성능 영향 측정 필요
- 데이터베이스 쿼리 최적화 필요

## 7. 결론 및 권장사항

### 7.1 검토 문서 평가

**전체 평가**: ✅ **매우 우수한 분석 및 제안**

**강점**:
1. 현재 구현의 문제점을 정확히 파악
2. 구체적이고 실현 가능한 개선 방안 제시
3. 우선순위가 명확함
4. 성능 및 확장성을 고려한 설계

**보완 사항**:
- 구현 복잡도 및 예상 작업 시간 추가 고려
- 단계별 마이그레이션 전략 제시 (기존 데이터 호환성)

### 7.2 즉시 적용 권장사항

**최우선 (Phase 1)**:
1. ✅ 좌표 page 기준 확장 (`page_x/page_y` 추가)
2. ✅ 디바이스 필터 추가
3. ✅ 그리드 해상도 200×200으로 증가

**이유**: 
- 구현 난이도 낮음
- 체감 개선 효과 큼
- 기존 데이터와 호환 가능 (하위 호환)

### 7.3 중기 개선 권장사항

**Phase 2 (1-2주 내)**:
1. 🟡 뷰포트 캔버스 + 스크롤 변환
2. 🟡 Blob 렌더링 (KDE)
3. 🟡 Dead/Rage click 요약 + AI 연동

**이유**:
- 상용 수준 품질 달성
- AI 분석 품질 향상
- 성능 최적화

### 7.4 장기 개선 권장사항

**Phase 3 (선택적)**:
1. 🟡 요소 기준 좌표 저장
2. 🟡 컨트롤 패널 확장
3. 🟡 스크롤맵 기능

**이유**:
- 추가 가치 제공
- 사용자 요구에 따라 선택적 적용

## 8. 다음 단계 제안

1. **검토 문서 승인**: 현재 문서의 분석 및 제안 승인
2. **Phase 1 구현 계획 수립**: 구체적인 작업 항목 및 일정
3. **프로토타입 개발**: Blob 렌더링 프로토타입으로 시각적 품질 확인
4. **성능 테스트**: 뷰포트 캔버스 방식의 성능 측정
5. **단계별 적용**: Phase 1 → Phase 2 → Phase 3 순차 적용

---

**작성일**: 2025-01-25  
**검토자**: AI Assistant  
**문서 버전**: 1.0

