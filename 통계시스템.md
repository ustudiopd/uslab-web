아래는 **현재 uslab.ai Step1(세션/페이지뷰 + `/api/track` + 대시보드)** 구조를 그대로 기반으로,
**세션 녹화(Session Recording)는 제외**하고도 “이식(shadcn식 Copy & Paste) 가능한” 형태로 확장하는 **통계/분석 v2 전체 명세서**입니다.

> 목표는 “라이브러리에 우리 코드 맞추기”가 아니라, **우리 코드베이스에 심을 수 있는 분석 코어(Tracker + Ingestion + DB + Rollup + Dashboard)를 표준화**하는 것입니다.

---

# USLAB Analytics v2 명세서

**(Session Replay 제외 / Heatmap + Funnel + Web Vitals + AI 요약 포함)**

* 문서 버전: v2.0 (Spec)
* 적용 대상: `uslab.ai` 1차 적용 후, 동일 모델을 `ustudio`, `modu`로 이식
* 전제: 하나의 Supabase 프로젝트 내에서 `{{prefix}}_` 테이블로 분리 운영

  * `ustudio_`, `modu_`, `uslab_` (기존 컨벤션 유지)

---

## 1. 목표와 비목표

### 1.1 목표

1. **공통 분석 코어**를 구축하여 서비스별로 “복붙 + prefix/env만 바꿔서” 이식 가능하게 한다.
2. Step1 KPI(오늘/7일/30일, Top Pages/Referrers 등)를 유지하면서, 아래 심화 기능을 추가한다.

   * **Events 테이블 기반** 확장
   * **히트맵(클릭/스크롤맵)**
   * **퍼널(이벤트 시퀀스)**
   * **Web Vitals 수집 및 집계**
   * (옵션) **AI 요약 리포트**(일일 자동)

### 1.2 비목표(Out of Scope)

* **세션 녹화(Session Replay)**: 구현/수집/저장/플레이어 포함 전체 제외

  * 향후 v3 후보로만 남겨둔다.

---

## 2. 현재 Step1 기준(현행 시스템)과 v2 확장 방향

### 2.1 Step1 현행 요약(기준점)

* Client: `components/analytics/Tracker.tsx`

  * App Router `usePathname`, `useSearchParams`로 라우팅 변경 감지
  * localStorage 세션키(`uslab_sid`) 기반 30분 TTL
  * `sendBeacon` 우선, fetch keepalive fallback
  * `/admin`, `/api`, `/_next` 제외
* API: `POST /api/track`

  * UA Bot filter
  * 세션 upsert + page_views insert
  * 에러가 나도 204 반환(UX 영향 최소)
* DB:

  * `uslab_sessions` / `uslab_page_views`
  * 세션에는 referrer/utm/device/user_agent 저장
  * page_views는 session FK + `view_duration`, `scroll_depth`(향후 활용 컬럼) 존재
* Dashboard:

  * `/api/admin/dashboard`에서 통계 집계 + UI `/admin/dashboard`

### 2.2 v2 확장 핵심

* **심화 기능은 전부 `{{prefix}}_events`를 중심으로 추가**
* **대시보드 성능을 위해 rollup(집계 테이블/뷰) 도입**
* **이식성 확보를 위해 prefix/env 설정형 구조로 리팩토링**

---

## 3. 멀티 서비스 이식 모델(Portable Model)

### 3.1 기본 원칙

* **DB는 prefix 분리**: `{{prefix}}_sessions`, `{{prefix}}_page_views`, `{{prefix}}_events`, …
* **코드는 공용**: Tracker/API/Queries는 최대한 동일 코드, prefix만 config로 주입
* **Domain 모듈 분리**: uslab 전용(블로그/SEO/댓글/문의)은 “옵션 모듈”로 분리

### 3.2 환경변수/설정(필수)

* `ANALYTICS_PREFIX`: `uslab | ustudio | modu`
* `ANALYTICS_ENABLED`: `true|false`
* `ANALYTICS_SAMPLE_RATE_EVENTS`: 기본 `1.0`(100%) 또는 `0.3` 등
* `ANALYTICS_SAMPLE_RATE_HEATMAP`: 기본 `1.0` 또는 `0.3`
* `ANALYTICS_EXCLUDE_PATH_PREFIXES`: `["/admin","/api","/_next"]` + 서비스별 추가
* (옵션) `ANALYTICS_RESPECT_DNT`: 기본 `true`

> 이식 시에는 “prefix + 대시보드용 도메인 모듈 on/off”만 바꾸는 걸 목표로 한다.

---

## 4. 데이터 모델 정의

### 4.1 용어

* **Session**: 30분 비활성 기준으로 끊기는 방문 단위(현재 구조 유지)
* **Page View**: 한 페이지 진입 인스턴스(라우트 변경 시 새로 생성)
* **Event**: 클릭/스크롤/전환/웹바이탈 등 “행동 단위”
* **Unique(고유 방문자)**: 기간 내 고유 `session_id` 수 (Step1 방식 유지)

### 4.2 핵심 설계 결정

* **page_view_id를 클라이언트에서 생성**하고 서버에 전달한다.

  * 이유: sendBeacon 기반에서도 “페이지뷰 인스턴스”를 안정적으로 식별할 수 있고,
  * 이벤트(클릭 등)를 해당 page_view에 연결하기 쉬워짐

---

## 5. 클라이언트 수집(Tracker/SDK) 명세

### 5.1 설치 방식(Next.js App Router)

* `app/layout.tsx` 또는 언어 라우트 layout에 `<Tracker />` 1회 삽입
* Tracker는 아래 기능을 수행:

  1. 세션키 관리
  2. page_view_start 전송
  3. 이벤트 큐(batch) 관리 및 flush
  4. click/scroll/web-vitals(옵션) 수집

### 5.2 세션키(session_key) 규칙

* 저장소: `localStorage`
* 키 이름: `${ANALYTICS_PREFIX}_sid` (uslab은 기존 `uslab_sid` 유지)
* TTL: **30분**
* 갱신: 페이지뷰 전송 시 “마지막 활동 시각” 갱신
* 생성: `crypto.randomUUID()`

### 5.3 page_path 정규화 규칙(중요)

v2부터는 아래를 표준으로 한다.

* `page_path` = **pathname만 저장** (예: `/ko/blog/hello`)
* query(`?utm_...`)는 기본적으로 `page_path`에 포함하지 않는다.
* 필요 시 별도 필드 `page_search` 또는 `page_url`로 저장(옵션)

> 이유: UTM/쿼리로 인해 “같은 페이지가 서로 다른 path로 폭발”하는 것을 막는다.

### 5.4 전송 방식(네트워크)

* 우선: `navigator.sendBeacon(url, blob)`
* fallback: `fetch(url, { keepalive: true })`
* 응답 처리: 응답 바디를 기대하지 않음(204)

### 5.5 이벤트 큐/배치 정책

* 이벤트는 즉시 전송하지 않고 **queue에 쌓아 배치** 전송 가능(기본 권장)
* flush 트리거:

  * `n개 이상 쌓이면`(예: 20개)
  * `T초마다`(예: 5초)
  * `visibilitychange: hidden` 또는 `pagehide` 시 강제 flush

### 5.6 수집 이벤트 종류(표준)

#### A) Page View Start (자동)

* 발생 시점: 라우트 변경 후 화면이 “진입”할 때
* 전송: `/api/track` payload의 `page_view`로 포함

필드:

* `page_view_id`(uuid, 클라이언트 생성)
* `page_path`(canonical)
* `locale`(ko/en)
* `referrer`(document.referrer)
* `utm_*`(URLSearchParams에서 파싱)
* `session_key`

#### B) Page Engagement End (자동, 선택)

* 목적: `view_duration`, `scroll_depth` 확보
* 발생 시점: 라우트 변경 직전(이전 페이지 종료) + 탭 숨김/이탈
* 방식: 이벤트로 전송(권장)

  * `event.name = "page_engagement"`
  * props: `{ view_duration_sec, scroll_depth_pct }`
  * `page_view_id` 포함

> Step1에 이미 page_views 컬럼이 있으니, 서버는 이 이벤트를 받으면 page_views row에 update(선택)하거나 events로만 남겨도 된다.

#### C) Click (히트맵용)

* 수집 방식: window click 리스너(capture)로 수집
* 필수 정책:

  * 입력 요소(input/textarea/contenteditable)는 기본 무시(개인정보 리스크)
  * `data-analytics-ignore` 있으면 무시
  * 중요한 요소는 `data-analytics-id="pay_button"`처럼 “안정적 ID” 권장

수집 필드:

* `event.name = "click"`
* `page_view_id`, `page_path`
* 좌표는 **정규화**:

  * `x = clientX / viewportW` (0~1)
  * `y = clientY / viewportH` (0~1)
* `viewport_w`, `viewport_h`
* `element_id`(data-analytics-id 우선)
* (옵션) `element_tag`, `href_host`, `text_len` 등 “비식별” 속성

#### D) Scroll Depth (스크롤맵/관심도)

* 스크롤 이벤트를 “매번 전송” 금지
* 페이지별 `max_scroll_pct`만 추적 후, 페이지 종료 시 1회 전송

수집 필드:

* `event.name = "scroll_depth"`
* props: `{ max_scroll_pct: 0~1 }`
* `page_view_id`, `page_path`

#### E) Conversion (전환 이벤트)

* 수집 방식: 개발자가 직접 호출
* 예: 문의 제출 성공, 회원가입 완료 등

수집 필드:

* `event.name = "conversion"`
* props: `{ key: "inquiry_submit", value?: number, meta?: {...} }`
* `page_view_id`, `page_path`

#### F) Web Vitals (옵션)

* Next.js `useReportWebVitals`로 수집
* `event.name = "web_vital"`
* props: `{ name: "LCP"|"CLS"|..., value: number, rating: "good"|"needs-improvement"|"poor" }`
* `page_view_id`, `page_path`

### 5.7 샘플링 정책

* **기본**: click/scroll은 100% 가능(부하 낮음)
* 트래픽 증가 시:

  * 이벤트 샘플링은 “세션 단위”로 결정(같은 세션은 항상 수집/항상 제외)
  * 예: `hash(session_key) % 100 < (sampleRate*100)`
* 샘플링 레이어:

  * `events_sample_rate`
  * `heatmap_sample_rate` (click만 별도 제어 가능)

---

## 6. 서버 Ingestion API 명세

### 6.1 Endpoint

* `POST /api/track`
* Public endpoint (인증 없이 접근 가능)
* 응답: **204 No Content** (성공/실패와 무관하게 UX 영향 최소화)

### 6.2 요청 Payload(표준)

```json
{
  "session_key": "uuid",
  "page_view": {
    "id": "uuid",
    "page_path": "/ko/blog/hello",
    "locale": "ko",
    "referrer": "https://google.com/..",
    "utm": {
      "source": "google",
      "medium": "cpc",
      "campaign": "winter"
    }
  },
  "events": [
    {
      "id": "uuid",
      "name": "click",
      "page_view_id": "uuid",
      "page_path": "/ko/blog/hello",
      "props": {
        "x": 0.41,
        "y": 0.78,
        "viewport_w": 390,
        "viewport_h": 844,
        "element_id": "cta_contact"
      },
      "client_ts": 1730000000000
    }
  ]
}
```

### 6.3 처리 로직(순서)

1. **Bot 필터링**

   * UA regex 기반(현재 규칙 유지)
   * bot으로 판단되면 저장하지 않고 204 반환

2. **Session Upsert**

   * key: `session_key`
   * 신규: landing_path/referrer/utm/device_type/user_agent 저장
   * 기존: last_seen_at 업데이트(단, **throttle 적용 권장**)

     * 예: last_seen_at이 최근 3분 이내면 update 생략

3. **Page View Upsert/Insert**

   * `page_view.id`를 PK로 사용(클라이언트 생성값)
   * `session_id` FK로 연결
   * `page_path`는 canonical 저장
   * (옵션) 도메인 매핑(`post_id/about_id`)은 **uslab 모듈에서만** 수행

4. **Events Bulk Insert**

   * `events[].id`를 PK로 (중복 전송 dedupe)
   * `session_id`를 저장(서버에서 세션 upsert 결과로 확보)
   * `page_view_id` 저장

5. 응답: 204

### 6.4 보안/안정성 정책

* 요청 데이터는 Zod 등으로 스키마 검증
* 비정상 payload는 저장하지 않고 204 반환(또는 400 선택 가능)
* 간단 rate-limit 권장:

  * IP/UA 기반 minute 단위 제한(서버리스/보안 수준에 맞게)
* 로그는 에러만 최소 기록(대량 로그 금지)

---

## 7. 데이터베이스 스키마(v2)

> 아래는 “Core Analytics” 기준.
> uslab 전용 domain(FK to posts/about)은 옵션으로 분리한다.

### 7.1 `{{prefix}}_sessions` (현행 유지)

* 현행 스키마 그대로 사용
* 권장 변경(선택):

  * `last_seen_at` 업데이트 빈도 throttling을 서버 로직으로 제어

### 7.2 `{{prefix}}_page_views` (확장)

현행은 `id`가 서버 생성이었으나, v2에서는 **클라이언트 생성 id를 삽입**하도록 표준화.

권장 컬럼(현행 + v2):

* `id uuid PK` (클라이언트 생성값 허용)
* `session_id uuid FK`
* `page_path text` (canonical)
* `locale varchar(10)`
* `view_duration integer null` (초)
* `scroll_depth integer null` (0~100)
* `created_at timestamptz`
* (옵션) `ended_at timestamptz`

> `view_duration/scroll_depth`는 `page_engagement` 이벤트로 받은 뒤 update할지(선택), rollup에서 계산할지(선택).

### 7.3 `{{prefix}}_events` (신규, 핵심)

권장 컬럼:

* `id uuid PK` (클라이언트 생성 event_id)
* `session_id uuid not null FK`
* `page_view_id uuid null FK` (page_views.id)
* `name text not null` (click/scroll_depth/conversion/web_vital/page_engagement/…)
* `page_path text not null` (canonical)
* `created_at timestamptz not null default now()`
* `client_ts bigint null`
* `props jsonb not null default '{}'::jsonb`

권장 인덱스:

* `(created_at desc)`
* `(page_path, name, created_at desc)`
* `(session_id, created_at desc)`
* `(page_view_id, created_at desc)`
* (히트맵용) props에서 `element_id`를 많이 쓸 경우:

  * 별도 컬럼 `element_id text`를 추출 저장(성능 위해) **또는**
  * generated column + index 고려

---

## 8. Rollup(집계) 설계 명세

> 목표: `/admin/dashboard`가 raw events/page_views를 매번 풀스캔하지 않도록.

### 8.1 최소 Rollup(필수)

1. `{{prefix}}_daily_stats`

* `day date`
* `pageviews int`
* `uniques int`

2. `{{prefix}}_daily_page_stats`

* `day date`
* `page_path text`
* `pageviews int`
* `uniques int`

3. `{{prefix}}_daily_referrer_stats`

* `day date`
* `referrer_host text`
* `sessions int`

### 8.2 히트맵 Rollup(권장)

4. `{{prefix}}_heatmap_element_daily`

* `day date`
* `page_path text`
* `element_id text`
* `clicks int`

5. `{{prefix}}_heatmap_grid_daily` (옵션, 좌표 시각화)

* `day date`
* `page_path text`
* `grid_size int` (예: 50)
* `device_bucket text` (mobile/desktop)
* `grid jsonb` (예: 50x50 count 배열)

> 초기에는 element heatmap만으로도 ROI가 매우 큼.
> grid는 “시각적 히트맵”이 꼭 필요할 때 추가.

### 8.3 퍼널 Rollup(필수)

6. `{{prefix}}_funnel_definitions`

* `id uuid PK`
* `name text`
* `steps jsonb`
  예:

  ```json
  [
    {"type":"page","path":"/ko/pricing"},
    {"type":"click","element_id":"cta_contact"},
    {"type":"conversion","key":"inquiry_submit"}
  ]
  ```

7. `{{prefix}}_funnel_daily`

* `day date`
* `funnel_id uuid`
* `step_index int`
* `sessions int`

### 8.4 Web Vitals Rollup(권장)

8. `{{prefix}}_web_vitals_daily`

* `day date`
* `metric text` (LCP/CLS/INP/…)
* `p50 numeric`, `p75 numeric`, `p95 numeric`
* `count int`
* `poor_rate numeric` (0~1)

---

## 9. Rollup 생성 방식(크론/스케줄) 명세

### 9.1 실행 주기

* 매일 1회 (KST 기준)
* 권장 시간: 00:10 KST ~ 00:30 KST

### 9.2 실행 방식

* Vercel Cron → `GET /api/analytics/rollup?day=YYYY-MM-DD`
* 이 API는 관리자/서비스 역할만 호출하도록 보호(서버에서만 사용)

### 9.3 Idempotency(중복 실행 안전)

* rollup은 “해당 day를 delete 후 insert” 또는 upsert로 구현
* 늦게 도착한 이벤트를 반영하기 위해:

  * 매일 실행 시 `day-1`, `day-2`까지 재계산 옵션(권장)

---

## 10. 통계/조회 API & Query Layer 명세

### 10.1 Query 함수 위치

* `lib/queries/analytics.ts` 유지
* v2에서는 prefix를 인자로 받거나, `createAnalyticsQueries(prefix)` 형태로 생성

### 10.2 필수 Query 함수(코어)

* `getTodayStats(prefix, tz='Asia/Seoul')`

* `getPeriodStats(prefix)` (7일, 30일)

* `getDailyStats(prefix, days)`

  * rollup 존재 시 rollup 사용
  * 없으면 raw에서 group by

* `getTopPages(prefix, days, limit)`

* `getTopReferrers(prefix, days, limit)`

### 10.3 히트맵 Query

* `getHeatmapTopElements(prefix, days, page_path?, limit)`
* (옵션) `getHeatmapGrid(prefix, days, page_path, grid_size, device_bucket)`

### 10.4 퍼널 Query

* `getFunnels(prefix)` (정의 목록)
* `getFunnelStats(prefix, funnel_id, days)`

  * day별 또는 기간 합산

### 10.5 Web Vitals Query

* `getWebVitals(prefix, days, metric?)`

---

## 11. Admin Dashboard 명세(v2)

### 11.1 기존 섹션 유지(현행)

* KPI 카드(오늘/7일/30일)
* 트래픽 추이 차트(Recharts)
* Top Posts / Top Referrers (uslab 도메인 포함)
* SEO 상태 모니터링(uslab 도메인 모듈)
* 최근 활동(포스트/댓글/문의)

### 11.2 v2 추가 섹션(코어)

1. **Heatmap(Elements) 카드**

* Top clicked elements (기간: 7일/30일)
* 필터: page_path(선택), locale(선택), device(선택)

2. **Scroll 관심도 카드**

* 페이지별 scroll_depth p50/p90 또는 평균
* “끝까지 읽히는 페이지 vs 안 읽히는 페이지” 식별

3. **Funnel 카드**

* 선택된 퍼널의 단계별 sessions 및 이탈률 표시
* 기간 선택(7/30/custom)

4. **Web Vitals 카드(옵션)**

* LCP/CLS/INP 등 p75 + poor_rate 표시
* 페이지별 상위 문제 페이지(옵션)

### 11.3 v2 추가 섹션(옵션)

* **AI 요약 리포트 카드**

  * “어제의 변화/이상징후/개선 제안” 텍스트
  * 소스: rollup 기반

---

## 12. 개인정보/보안/컴플라이언스 가이드(필수)

### 12.1 수집 금지(원칙)

* 폼 입력값/텍스트 내용/개인식별정보(이메일, 전화번호 등) 저장 금지
* full URL query 저장 최소화(utm 분리, 나머지 query는 기본 버림)
* 관리자 페이지(`/admin`) 이벤트 수집 금지(기본 exclude)

### 12.2 옵트아웃

* `Do Not Track`(navigator.doNotTrack) 존중 옵션 제공(기본 true 권장)
* (옵션) 쿠키 동의 기반으로 analytics 활성화

### 12.3 DB 접근 통제

* analytics raw/rollup 테이블은 기본적으로 **관리자만 조회**
* insert는 서버 API(`/api/track`)에서만 수행하도록 설계(서비스 role)

---

## 13. 성능/부하 예산(운영 기준)

### 13.1 클라이언트

* 클릭 이벤트: “좌표 계산 + 큐 push” 수준으로 체감 부하 거의 없음
* 스크롤: 매 scroll마다 전송 금지, max만 계산 후 exit 시 1회 전송
* 배치 전송으로 네트워크 호출 수 최소화

### 13.2 서버/DB

* events는 bulk insert 중심
* rollup 도입으로 대시보드 조회는 가벼운 쿼리로 제한
* retention 정책으로 raw 데이터 무한 증가 방지

---

## 14. 데이터 보존 정책(Retention)

* Raw:

  * `{{prefix}}_page_views`: 90일 (현행 유지)
  * `{{prefix}}_events`: 30~90일(권장 90일, 트래픽 따라 조정)
* Rollup:

  * 일 단위 집계: 1~2년(또는 영구)
* 정리 방식:

  * `cleanup_old_tracking_data()` 같은 함수 + 스케줄러 필수

---

## 15. 단계별 적용 계획(권장)

### Phase 0: Step1.5 정리(이식성 확보)

* page_path canonicalize (pathname만)
* last_seen_at update throttling
* daily stats를 DB 집계(rollup 또는 group by)
* retention 스케줄러 확실히 설정

### Phase 1: Events + 기본 히트맵

* `{{prefix}}_events` 추가
* `/api/track` payload에 `events[]` 추가
* click(정규화 좌표 + element_id), scroll_depth, conversion 수집
* admin에 element heatmap 카드 추가

### Phase 2: 퍼널 + rollup

* funnel definitions + daily rollup
* admin에 funnel 카드 추가

### Phase 3: Web Vitals + (옵션) AI 리포트

* web vitals 이벤트/rollup
* AI 요약: rollup 결과 기반으로 생성/저장/표시

---

## 16. “이식 패키지” 산출물 정의(복붙 가능한 단위)

세션녹화 제외 v2의 “노블sh 스타일” 목표 산출물은 아래 5개입니다.

1. **DB Migration 템플릿**

* `2025xxxx_create_{{prefix}}_events.sql`
* `2025xxxx_create_{{prefix}}_rollups.sql`
* `cleanup_old_tracking_data()` 포함

2. **Client Tracker 모듈**

* `components/analytics/Tracker.tsx` (config/prefix 기반)
* `lib/utils/tracking.ts` (track(), flush(), sampling, normalize 등)

3. **Ingestion API**

* `app/api/track/route.ts` (events batch + session/pageview upsert)

4. **Queries**

* `lib/queries/analytics.ts` (prefix 인자화 / rollup 우선)

5. **Dashboard 확장**

* `/api/admin/dashboard` 응답 확장
* `/admin/dashboard`에 Heatmap/Funnel/WebVitals 카드 추가

---

원하시면 다음 단계로, 이 명세서를 **“Cursor에게 바로 던질 수 있는 작업 단위(TODO/티켓)”**로 쪼개서

* 마이그레이션 템플릿(프리픽스 치환용)
* `/api/track` v2 request/response contract
* 히트맵 v1(Element heatmap) UI 요구사항
  까지 **정확히 “개발 체크리스트” 형태**로 변환해드릴게요.
