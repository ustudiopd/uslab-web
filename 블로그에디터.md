# 블로그 에디터 플랜 검토 및 개선안

## 현재 상황
- **Gemini API 키**: `.env.local`에 `GOOGLE_API_KEY`로 저장됨
- **모델**: `gemini-2.0-flash` 사용
- **프로젝트**: Next.js 14 (App Router), Supabase, Novel.sh 에디터

---

## 1. 패키지 설치 검토

### ✅ 권장 패키지 목록

```json
{
  "dependencies": {
    "ai": "^3.x.x",                    // Vercel AI SDK (최신, Streaming 지원)
    "@ai-sdk/google": "^0.x.x",       // Google Gemini SDK 통합
    "novel": "^0.0.xxx",              // Novel.sh 에디터
    "@tiptap/react": "^2.x.x",
    "@tiptap/starter-kit": "^2.x.x",
    "@tiptap/extension-markdown": "^2.x.x",
    "@tailwindcss/typography": "^0.5.x"
  }
}
```

### ⚠️ 주의사항
- **`ai`** 패키지를 사용 (과거 `@vercel/ai`에서 변경됨, 2025년 기준)
- **`@ai-sdk/google`** 패키지로 Gemini를 Vercel AI SDK와 편하게 연동
- Vercel AI SDK는 Streaming 응답을 자동으로 처리

---

## 2. 환경 변수 설정

### `.env.local` 구조

```env
# Supabase (기존)
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key

# Google Gemini API (추가)
GOOGLE_API_KEY=your_gemini_api_key
```

**⚠️ 중요**: `@ai-sdk/google`는 자동으로 `GOOGLE_API_KEY` 환경 변수를 읽어서 사용합니다.

### ✅ 확인 사항
- `GOOGLE_API_KEY`가 이미 `.env.local`에 설정되어 있음
- 서버 사이드에서만 사용 (클라이언트에 노출되지 않음)

---

## 3. AI API 엔드포인트 구현

### 3-1. `/api/ai/generate` - AI 이어쓰기

**목적**: Novel.sh 에디터의 AI 이어쓰기 기능

**구현 예시**:
```typescript
// app/api/ai/generate/route.ts
import { google } from '@ai-sdk/google';
import { streamText } from 'ai';

export async function POST(req: Request) {
  const { prompt, context } = await req.json();
  
  // Vercel AI SDK로 간결하게 구현
  const result = await streamText({
    model: google('models/gemini-2.0-flash'), // 모델명만 지정
    prompt: `${context}\n\n계속 작성해주세요: ${prompt}`,
  });
  
  // Streaming 응답 자동 처리
  return result.toDataStreamResponse();
}
```

### 3-2. `/api/ai/refine` - 문단별 AI 교정

**목적**: 선택한 문단을 AI로 교정 (톤앤매너, 문법, 가독성)

**구현 예시**:
```typescript
// app/api/ai/refine/route.ts
import { google } from '@ai-sdk/google';
import { generateText } from 'ai';

export async function POST(req: Request) {
  const { text, tone_prompt, locale } = await req.json();
  
  const prompt = `
다음 텍스트를 ${locale === 'ko' ? '한국어' : '영어'}로 교정해주세요.
${tone_prompt ? `톤앤매너: ${tone_prompt}` : ''}

원본:
${text}

교정된 텍스트와 수정 이유를 JSON 형식으로 반환해주세요:
{
  "original": "원본 텍스트",
  "suggested": "교정된 텍스트",
  "reason": "수정 이유",
  "diff": "변경 사항 요약"
}
  `;
  
  // Vercel AI SDK로 간결하게 구현
  const { text: responseText } = await generateText({
    model: google('models/gemini-2.0-flash'),
    prompt,
  });
  
  // JSON 파싱 및 반환
  return Response.json(JSON.parse(responseText));
}
```

### 3-3. `/api/ai/seo` - SEO 메타데이터 자동 생성

**목적**: 발행 시 SEO 제목, 설명, 키워드 자동 생성

**구현 예시**:
```typescript
// app/api/ai/seo/route.ts
import { google } from '@ai-sdk/google';
import { generateText } from 'ai';

export async function POST(req: Request) {
  const { full_content, title, locale } = await req.json();
  
  const prompt = `
다음 블로그 포스트의 SEO 메타데이터를 생성해주세요.

제목: ${title}
내용: ${full_content.substring(0, 2000)}...

다음 JSON 형식으로만 응답해주세요 (반드시 JSON 형식):
{
  "seo_title": "검색 엔진 최적화된 제목 (60자 이내)",
  "seo_description": "검색 엔진 최적화된 설명 (160자 이내)",
  "seo_keywords": ["키워드1", "키워드2", "키워드3"]
}

주의: seo_keywords는 반드시 JSON 배열(string[]) 형식으로만 응답하세요.
  `;
  
  // Vercel AI SDK로 간결하게 구현
  const { text: responseText } = await generateText({
    model: google('models/gemini-2.0-flash'),
    prompt,
  });
  
  // JSON 파싱 및 반환
  const seoData = JSON.parse(responseText);
  
  return Response.json({
    seo_title: seoData.seo_title,
    seo_description: seoData.seo_description,
    seo_keywords: seoData.seo_keywords, // 이미 배열 형식
  });
}
```

---

## 4. Novel.sh 에디터 통합

### 4-1. 기본 에디터 설정

```typescript
// app/admin/posts/write/page.tsx
import { Editor } from 'novel';
import { extensions } from '@/lib/editor/extensions';

export default function WritePage() {
  return (
    <Editor
      extensions={extensions}
      onUpdate={({ editor }) => {
        // 자동 저장 로직
        const json = editor.getJSON();
        // localStorage 또는 debounce로 서버 저장
      }}
    />
  );
}
```

### 4-2. AI 이어쓰기 통합

```typescript
// Novel.sh의 AI 기능과 Gemini 연동
import { useAI } from 'novel/react';
import { useCompletion } from 'ai/react'; // 'ai' 패키지에서 import

function AICompletion() {
  const { completion, complete } = useCompletion({
    api: '/api/ai/generate',
  });
  
  // Novel.sh 에디터에 completion 삽입
  return (
    <button onClick={() => complete(prompt)}>
      AI로 이어쓰기
    </button>
  );
}
```

---

## 5. AI Copilot UI 구현

### 5-1. 문단 선택 시 AI 수정 버튼

```typescript
// components/blog/AICopilot.tsx
'use client';

import { useState } from 'react';

export function AICopilot({ selectedText, onApply }: Props) {
  const [loading, setLoading] = useState(false);
  const [suggestion, setSuggestion] = useState(null);
  
  const handleRefine = async () => {
    setLoading(true);
    const response = await fetch('/api/ai/refine', {
      method: 'POST',
      body: JSON.stringify({ text: selectedText }),
    });
    const data = await response.json();
    setSuggestion(data);
    setLoading(false);
  };
  
  return (
    <div className="ai-copilot-panel">
      <button onClick={handleRefine}>AI로 수정</button>
      {suggestion && (
        <DiffView
          original={suggestion.original}
          suggested={suggestion.suggested}
          reason={suggestion.reason}
          onAccept={() => onApply(suggestion.suggested)}
          onReject={() => setSuggestion(null)}
        />
      )}
    </div>
  );
}
```

### 5-2. Diff View 컴포넌트

```typescript
// components/blog/DiffView.tsx
export function DiffView({ original, suggested, reason, onAccept, onReject }) {
  return (
    <div className="diff-view">
      <div className="original">
        <h3>원본</h3>
        <p>{original}</p>
      </div>
      <div className="suggested">
        <h3>제안</h3>
        <p>{suggested}</p>
      </div>
      <div className="reason">
        <p>{reason}</p>
      </div>
      <div className="actions">
        <button onClick={onAccept}>수락</button>
        <button onClick={onReject}>거절</button>
      </div>
    </div>
  );
}
```

---

## 6. 발행 프로세스 개선

### 6-1. 동기 SEO 생성 (초기 전략)

```typescript
// app/admin/posts/write/page.tsx
async function handlePublish() {
  // 1. SEO 메타데이터 생성 (AI)
  const seoResponse = await fetch('/api/ai/seo', {
    method: 'POST',
    body: JSON.stringify({
      full_content: editor.getHTML(),
      title: title,
      locale: locale,
    }),
  });
  const seoData = await seoResponse.json();
  
  // 2. 포스트 저장
  await fetch('/api/posts', {
    method: 'POST',
    body: JSON.stringify({
      title,
      content: editor.getJSON(),
      locale,
      seo_title: seoData.seo_title,
      seo_description: seoData.seo_description,
      seo_keywords: seoData.seo_keywords,
      is_published: true,
      published_at: new Date().toISOString(),
    }),
  });
  
  // 3. 캐시 재검증
  revalidatePath(`/${locale}/blog`);
}
```

### 6-2. 향후 비동기 전환 (선택적)

```typescript
// 비동기 SEO 생성 (백그라운드)
async function handlePublish() {
  // 1. 포스트 즉시 발행
  const post = await createPost({ ... });
  
  // 2. SEO는 백그라운드로 생성
  fetch('/api/ai/seo', {
    method: 'POST',
    body: JSON.stringify({ post_id: post.id, ... }),
  }).then(async (seoData) => {
    await updatePost(post.id, { ...seoData });
  });
}
```

---

## 7. 에러 처리 및 최적화

### 7-1. API 에러 처리

```typescript
// lib/ai/error-handler.ts
export function handleAIError(error: Error) {
  if (error.message.includes('API_KEY')) {
    return 'Gemini API 키가 유효하지 않습니다.';
  }
  if (error.message.includes('QUOTA')) {
    return 'API 사용량 한도를 초과했습니다.';
  }
  return 'AI 요청 중 오류가 발생했습니다.';
}
```

### 7-2. Rate Limiting

```typescript
// lib/ai/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '1 m'), // 1분에 10회
});

export async function checkRateLimit(userId: string) {
  const { success } = await ratelimit.limit(userId);
  if (!success) {
    throw new Error('요청 한도를 초과했습니다.');
  }
}
```

---

## 8. 검토 포인트 및 개선사항

### ✅ 잘 된 점
1. **Gemini 2.0 Flash 선택**: 빠른 응답 속도, 긴 문맥 이해
2. **환경 변수 설정**: `GOOGLE_API_KEY`로 명확하게 설정
3. **Phase별 단계적 구현**: Phase 1 → Phase 2 → Phase 3 순서

### ⚠️ 개선 필요 사항

1. **패키지 버전 명시**
   - `ai`: 최신 버전 확인 필요 (과거 `@vercel/ai`에서 변경됨)
   - `@ai-sdk/google`: 최신 버전 확인 필요
   - `novel`: 버전 호환성 확인 필요

2. **모델 이름 확인**
   - ✅ `gemini-2.0-flash` (표준 버전) 사용 확정
   - 또는 `gemini-2.5-flash` (최신 버전, 선택적)
   - `gemini-2.0-flash-exp`는 사용하지 않음

3. **Streaming vs Non-Streaming**
   - AI 이어쓰기: Streaming 권장 (사용자 경험)
   - SEO 생성: Non-Streaming 가능 (한 번에 결과 필요)

4. **프롬프트 엔지니어링**
   - 한국어/영어 프롬프트 최적화
   - JSON 응답 형식 강제 (구조화된 출력)

5. **비용 최적화**
   - 토큰 사용량 모니터링
   - 캐싱 전략 (같은 콘텐츠에 대한 중복 요청 방지)

---

## 9. 구현 우선순위

### Phase 1 (기본)
1. ✅ Novel.sh 에디터 통합 (최소 버전)
2. ✅ 기본 CRUD 기능

### Phase 2 (에디터 고급 기능)
1. ✅ 슬래시 메뉴, 드래그앤드롭
2. ✅ 이미지 업로드
3. ✅ 자동 저장

### Phase 3 (AI 기능)
1. ✅ AI 이어쓰기 (`/api/ai/generate`)
2. ✅ AI 교정 (`/api/ai/refine`)
3. ✅ SEO 자동 생성 (`/api/ai/seo`)
4. ✅ AI Copilot UI

---

## 10. 다음 단계

1. **패키지 설치 확인**
   ```bash
   npm install ai @ai-sdk/google novel @tiptap/react @tiptap/starter-kit @tiptap/extension-markdown @tailwindcss/typography
   ```

2. **환경 변수 확인**
   - `.env.local`에 `GOOGLE_API_KEY` 설정 확인

3. **테스트 API 엔드포인트 작성**
   - `/api/ai/test` 엔드포인트로 Gemini 연결 테스트

4. **Novel.sh 에디터 기본 통합**
   - Phase 1에서 최소 버전으로 시작

---

**검토 완료**: 이 플랜은 plan.md의 Phase 2-3와 일관성 있으며, Gemini 2.0 Flash 통합 방향이 명확합니다. 위의 개선사항을 반영하면 바로 구현 가능합니다.
