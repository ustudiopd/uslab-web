좋아. 아래는 **내가 추천했던 흐름(EN 최초 생성 = KO 구조 그대로 복사 + 텍스트만 번역 / 이후 EN에서 이미지 교체·저장 / 번역 업데이트는 EN 이미지 유지)** 그대로 진행되게 만든 **Cursor용 명세서**야.

참고로, 지금 Novel 편집기 쪽은 `/` 슬래시 메뉴가 안 뜨고 `EditorCommand` DOM이 렌더링되지 않는 런타임 이슈가 이미 확인된 상태라 , **이번 “번역/버전 탭” 작업은 에디터(노션 UX) 문제와 분리해서 먼저 구현**하는 걸 기준으로 작성했어.

---

# [Cursor Spec] KO/EN 버전 탭 + Gemini 2.0 Flash 번역 (KO 구조 복제 & 이미지 유지)

## 0) 한 문장 요약

* **KO 글을 기준으로 EN을 “복제본”으로 만들고(Create)**: KO의 Tiptap JSON 구조/이미지 그대로 + 텍스트만 번역
* 이후 **EN에서 이미지를 지우고 새 이미지 삽입 → EN content에 저장(독립 버전)**
* **업데이트(Update)** 버튼은 기본적으로 **EN 구조/이미지 유지 + 텍스트만 재번역 반영**

---

## 1) 목표

1. 관리자 포스트 편집 화면에서 `한국어 | English`를 “언어 선택 값”이 아니라 **언어별 버전 탭**으로 동작시킨다.
2. EN 버전이 없으면: EN 탭에서 **[영문 번역으로 초안 생성]** 버튼으로 1클릭 생성(Create)
3. EN 버전이 있으면: EN 탭에서 편집 가능 + **[자동 번역 업데이트]** 버튼으로 텍스트만 업데이트(Update)
4. 번역 모델은 **gemini-2.0-flash**를 사용하고, **자연스러운 기술 블로그 톤(en-US)**을 최우선으로 한다.
5. KO → EN으로 옮길 때 **이미지는 무조건 KO 구조 그대로 복사**되어 EN에 그대로 노출되어야 한다(추후 EN에서 교체 가능).

---

## 2) Non-goals

* 공개(퍼블릭) 페이지의 i18n 라우팅 구조 변경은 포함하지 않음
* Novel “노션급 UX(슬래시 메뉴/버블 메뉴)” 개선은 별도 트랙(현재 런타임 이슈 존재) 
* 완전한 diff 기반 부분 업데이트(문장 단위 merge)는 v2로 미룸

---

## 3) 핵심 UX 플로우

### 3.1 관리자 편집 화면 탭 동작

* **KO 탭**: `locale='ko'` 포스트 로드
* **EN 탭**: 같은 canonical 그룹의 `locale='en'` 포스트를 로드

  * 없으면 Empty State 표시

탭 UI에서 표시할 상태:

* `발행됨/초안` 배지(언어별 독립)
* “EN 없음” 배지(EN row가 없을 때)

### 3.2 EN이 없을 때 (EN 탭)

Empty State:

* 문구: “영문 버전이 아직 없습니다.”
* 버튼:

  1. **[영문 번역으로 초안 생성]** ✅ (기본)
  2. (옵션) [빈 영문 초안 만들기]

동작:

* 버튼 클릭 → 서버 번역(Create) 실행 → EN row 생성 → EN 탭에 번역된 content 로드 → 바로 편집 가능

### 3.3 EN이 있을 때 (EN 탭)

버튼:

* **[자동 번역 업데이트]** (텍스트만 업데이트 기본)
* (옵션) “고급” 메뉴에 **[KO 구조로 재생성(덮어쓰기)]** 넣기 (경고 + 롤백)

동작:

* **자동 번역 업데이트(기본)**: EN의 이미지/구조는 그대로 두고 **텍스트만 KO 최신으로 재번역해 반영**
* **KO 구조 재생성(옵션)**: KO 구조로 EN을 통째로 리베이스(이미지도 KO로 덮임) → 실행 전 경고 필수

---

## 4) 데이터/그룹 규칙

* EN은 KO의 “다른 버전”이므로 **반드시 다른 row(postId)** 로 존재한다.
* 두 버전은 `canonical_id`로 같은 그룹으로 묶는다.
* slug 정책(v1):

  * 기본은 **KO slug를 EN도 그대로 사용** (locale이 달라서 충돌 없음)
  * 추후 언어별 slug를 달리하고 싶으면 v2에서 변경

---

## 5) 번역 품질 설계 (Gemini 2.0 Flash 최적화)

### 5.1 가장 중요한 원칙: “구조 보존 번역”

* 번역은 **Tiptap JSON을 새로 생성하는 것이 아니라**,
* **KO의 content JSON을 deep clone**한 뒤,
* **텍스트 노드(text)만 번역해서 치환**한다.
* 따라서 **이미지(Image node), 링크 URL, 코드블록**은 절대 깨지지 않는다.

### 5.2 번역 대상/비대상 규칙

번역 대상:

* heading/paragraph/listItem/blockquote 안의 text node
* (옵션) 이미지 alt(기본은 번역 안 함)

번역 제외:

* codeBlock 내부 텍스트
* inline code 마크가 있는 텍스트
* 링크 URL (href)
* 이미지 src

### 5.3 자연스러운 번역을 위한 프롬프트 가이드

* 톤: “기술 블로그” + “자연스러운 en-US”
* 금지: 직역, 과장된 마케팅 문구, 원문에 없는 내용 추가
* 용어 사전(번역하지 않을 용어): SOP, LLM, agent, USlab.ai, RAG, TTS, API, SDK 등은 그대로/일관되게 유지

### 5.4 프롬프트 템플릿 예시

**System Prompt:**
```
You are a professional translator/editor for a technical blog.
- Translate Korean to natural US English
- Maintain technical terms: SOP, LLM, agent, USlab.ai, RAG, TTS, API, SDK (do not translate)
- Keep code blocks, URLs, and inline code unchanged
- Return valid JSON only
```

**User Prompt (실제 사용 예시):**
```
Translate the following text segments while maintaining their IDs:

ID: seg_1
Text: 류샤오파이 사건이 드러낸 '에이전트 개발'의 승부처

ID: seg_2
Text: SOP가 곧 경쟁력입니다

...

Return JSON in this format:
{
  "translations": [
    { "id": "seg_1", "text_en": "translated text" },
    { "id": "seg_2", "text_en": "translated text" },
    ...
  ]
}

Important: Return the same number of translations as input segments. Keep all IDs.
```

### 5.5 성능 최적화(토큰/속도)

* LLM에 **문서 전체(JSON)** 를 보내지 않는다.
* “번역 대상 텍스트 세그먼트 배열”만 보낸다.
* 세그먼트가 많으면 chunking:

  * 예: 120~200 세그먼트 단위로 분할
  * 각 chunk는 같은 스타일 가이드/용어 규칙을 공유
  * **병렬 처리**: 여러 chunk를 `Promise.all`로 동시에 번역 (성능 향상)
* temperature는 낮게(예: 0.2~0.35) 설정해 일관성 확보
* **타임아웃**: Gemini API 호출 타임아웃 설정 (예: 60초)
* **재시도 로직**: 네트워크 오류 시 exponential backoff로 최대 2회 재시도

---

## 6) API 명세

### 6.1 Endpoint

`POST /api/ai/translate-post`

### 6.2 Request JSON

```json
{
  "sourcePostId": "uuid",
  "targetLocale": "en",
  "mode": "create" | "update",
  "updateStrategy": "text_only" | "rebase_from_ko",
  "translateSeo": true,
  "preserveSlug": true
}
```

### 6.3 Response JSON

**성공 응답 (200):**
```json
{
  "ok": true,
  "targetPostId": "uuid",
  "created": true,
  "warnings": [],
  "stats": {
    "segmentsIn": 123,
    "segmentsTranslated": 123,
    "segmentsSkipped": 0
  }
}
```

**에러 응답 예시:**

**400 Bad Request:**
```json
{
  "ok": false,
  "error": "Invalid request",
  "code": "INVALID_REQUEST",
  "details": "sourcePostId is required"
}
```

**401 Unauthorized:**
```json
{
  "ok": false,
  "error": "Unauthorized",
  "code": "UNAUTHORIZED",
  "details": "Authentication required"
}
```

**404 Not Found:**
```json
{
  "ok": false,
  "error": "Source post not found",
  "code": "POST_NOT_FOUND",
  "details": "Post with id 'uuid' does not exist"
}
```

**409 Conflict (구조 mismatch):**
```json
{
  "ok": false,
  "error": "Structure mismatch",
  "code": "STRUCTURE_MISMATCH",
  "details": "EN 텍스트 노드 수(45)와 KO 텍스트 노드 수(52)가 다릅니다. rebase_from_ko 전략을 사용하거나 EN 구조를 KO와 맞춰주세요.",
  "stats": {
    "koSegments": 52,
    "enSegments": 45,
    "mismatch": 7
  },
  "suggestion": "Use updateStrategy='rebase_from_ko' to regenerate from KO structure"
}
```

**500 Internal Server Error:**
```json
{
  "ok": false,
  "error": "Translation failed",
  "code": "TRANSLATION_ERROR",
  "details": "Gemini API error: ..."
}
```

### 6.4 권한

* 관리자(로그인 세션)만 접근 가능
* 클라이언트는 content를 보내지 않고 **sourcePostId만 보내며**, 서버가 DB에서 원문을 읽는다.
* **RLS 정책 확인**: authenticated 사용자가 draft(`is_published=false`)를 조회할 수 있는지 확인 필요
  * 현재: `uslab_policy_posts_select_public`은 `is_published=true`만 허용
  * 필요: authenticated 사용자용 SELECT 정책 추가 또는 기존 정책 수정

### 6.5 환경 변수

* `GOOGLE_API_KEY` 또는 `GOOGLE_GENERATIVE_AI_API_KEY` 사용 가능
* 코드에서 자동 매핑 처리됨 (기존 `/api/ai/generate/route.ts` 패턴 참고)
* 서버 사이드에서만 사용 (클라이언트에 노출되지 않음)

---

## 7) 서버 동작 상세

### 7.1 Create (EN 최초 생성) — ✅ 네가 원하는 “이미지 그대로 복사” 핵심

1. `sourcePostId`로 KO 포스트 로드
2. `baseDoc = deepClone(source.content)`

   * 이 단계에서 **이미지 노드 포함 모든 구조가 그대로 따라옴**
3. `collectSegmentsFromDoc(source.content)`로 번역 대상 text 세그먼트 수집
4. Gemini 번역 호출(세그먼트 배열 → 번역 배열)
5. `applyTranslationsByPath(baseDoc, translations)`로 baseDoc에 텍스트만 치환
6. EN row 생성(upsert):

   * `locale='en'`
   * `canonical_id = koPost.canonical_id ?? koPost.id`
   * `slug = koPost.slug` (preserveSlug=true)
   * `title/content/seo_*` = 번역 결과
   * `is_published=false` (초안)

**결과:** EN은 KO와 같은 이미지/레이아웃을 갖고, 텍스트만 영어로 채워짐.

### 7.2 Update (EN 업데이트) — ✅ EN에서 이미지 바꿔도 유지되게

기본은 `updateStrategy="text_only"`.

**text_only 업데이트 알고리즘(권장 v1): “경로 기반 매칭 + 순서 기반 fallback”**

* 목표: EN 문서에서 이미지 노드를 삭제/추가해도 **안전하게 텍스트만 업데이트**되게 만들기.
* 전략: 경로 기반 매칭을 우선 시도하고, 실패 시 순서 기반 매칭으로 fallback

절차:

1. source(KO)와 target(EN) content 로드
2. KO에서 번역 대상 세그먼트를 **JSON 경로(path)**와 함께 수집
   * 예: `{ path: [0, 'content', 0, 'text'], text: "...", nodeType: "paragraph" }`
3. EN에서도 같은 방식으로 경로와 함께 수집
4. **1차: 경로 기반 매칭 시도**
   * KO와 EN의 JSON 구조를 비교
   * 같은 경로에 있는 텍스트 노드만 매칭
   * 매칭률 계산: `matchedPaths / totalPaths`
   * 매칭률이 80% 이상이면 경로 기반 매칭 사용
5. **2차: 경로 매칭 실패 시 순서 기반 매칭 (fallback)**
   * 경로 매칭률이 80% 미만이면 순서 기반으로 전환
   * KO와 EN의 텍스트 노드를 DFS 순서대로 수집
   * 길이 비교:
     * KO 세그먼트 개수 = EN 세그먼트 개수면 → 1:1로 index 매칭하여 치환
     * 다르면:
       * mismatch가 크면(20% 이상 차이) → 409 + 경고(“EN 구조가 많이 달라져 text-only 업데이트가 안전하지 않음 → rebase 추천”)
       * mismatch가 작으면(20% 미만) → min length까지 적용 + warnings 리턴
6. Gemini로 KO 세그먼트 번역
7. EN content는 구조/이미지 노드는 건드리지 않고, **텍스트만 치환한 결과를 저장**

![LG CNS AX 플랫폼 아키텍처 시각화](../assets/c__Users_Ustudio001_AppData_Roaming_Cursor_User_workspaceStorage_660fcffaf4adc12b0cb968b4b036d942_images_image-8c168922-4a1c-4491-984a-3898000d7758.png)

LG CNS
Architecture
AX 플랫폼 아키텍처 시각화
복잡한 AX 플랫폼 개념을 고객들에게 쉽게 전달하기 위해, Google Imagen4 API로 12,000장의 이미지를 제작했습니다.

![Microsoft AI Copilot 인지도 확산](../assets/c__Users_Ustudio001_AppData_Roaming_Cursor_User_workspaceStorage_660fcffaf4adc12b0cb968b4b036d942_images_image-8c168922-4a1c-4491-984a-3898000d7758.png)

Microsoft
Marketing
AI Copilot 인지도 확산
Microsoft와 협력해 유튜버 미미미누의 Copilot 영상(200만 뷰)과 인사혁신처 인재개발 플랫폼 콘텐츠를 기획·제작

![행정안전부 공공혁신 해커톤 'Hack for Public'](../assets/c__Users_Ustudio001_AppData_Roaming_Cursor_User_workspaceStorage_660fcffaf4adc12b0cb968b4b036d942_images_image-8c168922-4a1c-4491-984a-3898000d7758.png)

행정안전부
Hackathon
공공혁신 해커톤 'Hack for Public'
행정안전부, KDI국제정책대학원, Microsoft와 함께 공공 혁신 해커톤을 기획·운영하여 정책 혁신 기반을 강화했습니다.

> 경로 기반 매칭이 더 안전하지만, EN에서 구조를 크게 변경한 경우 순서 기반 fallback이 유용함.

**옵션: rebase_from_ko**

1. EN 업데이트 전 스냅샷 저장(rollback 용도)
2. Create와 동일하게 KO 구조를 clone → 텍스트 번역 적용
3. EN content를 통째로 교체
   ⚠️ 이 경우 EN에서 바꾼 이미지도 KO 이미지로 되돌아갈 수 있으니 UI 경고 필수.

---

## 8) Gemini(google) 호출 명세 (Cursor 구현 지시)

> 프로젝트가 이미 Vercel AI SDK + Gemini 통합을 진행 중이므로 , 기존 `/api/ai/slug` 라우트 스타일을 그대로 따라가서 작성.

### 8.1 입력/출력 스키마(Structured Output 강제)

* 입력: `{ segments: [{ id, text, hint }] }`
* 출력: `{ translations: [{ id, text_en }] }`

검증:

* output의 id set이 input과 동일해야 함
* 누락/중복 시:

  * 1회 재시도(더 엄격한 프롬프트)
  * 그래도 실패하면 해당 segment는 원문 유지 + warnings

### 8.2 프롬프트(권장 템플릿)

System:

* “You are a professional translator/editor for a technical blog.”
* “Translate Korean to natural US English.”
* “Do not translate code/URLs/product names; keep abbreviations consistent.”
* “Return valid JSON only.”

User:

* 스타일 가이드(짧게)
* 세그먼트 배열
* “id를 유지하고, 동일 개수로 반환하라”

**프롬프트 파라미터:**

* `temperature`: 0.2~0.35 (일관성 확보)
* `maxTokens`: 8192 (Gemini 2.0 Flash 기본값)
* `timeout`: 60000ms (60초)

**구현 예시:**
```typescript
import { google } from '@ai-sdk/google';
import { generateObject } from 'ai';
import { z } from 'zod';

const translationSchema = z.object({
  translations: z.array(
    z.object({
      id: z.string(),
      text_en: z.string(),
    })
  ),
});

const result = await generateObject({
  model: google('models/gemini-2.0-flash'),
  schema: translationSchema,
  prompt: userPrompt,
  temperature: 0.3,
  maxTokens: 8192,
});

// result.object.translations 사용
```

---

## 9) UI 컴포넌트/파일 변경(권장)

### 9.1 신규 컴포넌트

* `components/admin/PostVersionTabs.tsx`

  * props: `{ canonicalRootId, koPostId, initialTab?: 'ko'|'en' }`
  * 역할: KO/EN 로드, 탭 전환, 상태 배지, 번역 버튼 호출
  * 상태 관리:
    * `loading`: 번역 진행 중 여부
    * `error`: 에러 메시지 (409 시 rebase 옵션 제시)
    * `success`: 번역 완료 피드백

* `components/admin/TranslateActions.tsx`

  * 역할: Create / Update 버튼 + 모달(옵션 전략)
  * UI 상태:
    * 로딩 인디케이터: 번역 중 표시
    * 에러 모달: 409 에러 시 rebase 옵션 제시
    * 성공 토스트: 번역 완료 후 피드백

### 9.2 API Route

* `app/api/ai/translate-post/route.ts`

  * 관리자 인증
  * DB read
  * 번역 수행(gemini-2.0-flash)
  * DB upsert

### 9.3 번역 유틸

* `lib/translate/tiptapSegments.ts`

  **타입 정의:**
  ```typescript
  interface TextNodeRef {
    id: string;              // 세그먼트 고유 ID (예: "seg_1")
    path: number[];          // JSON 경로 (예: [0, 'content', 0, 'text'])
    text: string;            // 번역할 텍스트
    nodeType: string;        // 'heading' | 'paragraph' | 'listItem' | 'blockquote' | ...
    hasCodeMark?: boolean;   // inline code 마크가 있는지
    hint?: string;           // 컨텍스트 힌트 (선택적)
  }
  ```

  **함수 시그니처:**
  ```typescript
  /**
   * Tiptap JSON 문서에서 번역 대상 텍스트 노드를 수집
   * @param doc Tiptap JSONContent
   * @param path 현재 경로 (재귀용)
   * @returns 번역 대상 텍스트 노드 배열 (경로 포함)
   */
  function collectTranslatableTextNodes(
    doc: JSONContent,
    path: number[] = []
  ): TextNodeRef[] {
    // DFS로 순회하며 텍스트 노드 수집
    // codeBlock 내부, inline code 마크 제외
    // 경로 정보 포함하여 반환
  }

  /**
   * 경로 기반으로 번역 결과를 문서에 적용 (Create 시 사용)
   */
  function applyTranslationsByPath(
    doc: JSONContent,
    translations: Array<{ id: string; text_en: string }>,
    refs: TextNodeRef[]
  ): JSONContent {
    // refs의 path를 따라가서 텍스트만 치환
  }

  /**
   * 인덱스 기반으로 번역 결과를 문서에 적용 (Update 시 순서 기반 매칭)
   */
  function applyTranslationsByIndex(
    doc: JSONContent,
    refs: TextNodeRef[],
    translations: Array<{ id: string; text_en: string }>
  ): JSONContent {
    // refs의 순서대로 텍스트 치환
  }

  /**
   * 경로 기반 매칭률 계산
   */
  function calculatePathMatchRate(
    koRefs: TextNodeRef[],
    enRefs: TextNodeRef[]
  ): number {
    // 같은 경로를 가진 텍스트 노드 비율 계산
    // 반환값: 0.0 ~ 1.0
  }
  ```

---

## 10) 완료 조건(Acceptance Criteria)

### Create

1. KO 포스트에서 EN 탭 → “영문 버전 없음” 표시
2. [영문 번역으로 초안 생성] 클릭
3. EN 초안이 생성되고(새 postId), EN 탭에 바로 로드됨
4. **이미지가 KO와 1:1로 동일하게 노출됨**(src 동일)
5. 코드블록/URL이 번역으로 훼손되지 않음

### EN에서 이미지 교체

1. EN 탭에서 이미지 삭제 후 새 이미지 삽입
2. 저장 후 새로고침해도 EN에서만 변경된 이미지가 유지됨

### Update(text_only)

1. EN에서 이미지 교체한 상태에서 [자동 번역 업데이트] 실행
2. **이미지는 그대로 유지되고**, 텍스트만 업데이트됨
3. mismatch 발생 시:
   * 경로 매칭률 80% 이상: 경로 기반 매칭으로 안전하게 업데이트
   * 경로 매칭률 50~80%: 순서 기반 fallback으로 업데이트 + warnings
   * 경로 매칭률 50% 미만 또는 세그먼트 수 차이 20% 이상: 409 에러 + rebase 안내 모달 표시

### 엣지 케이스 테스트

1. **KO에 이미지 없음**: 정상 작동 (텍스트만 번역)
2. **KO에 코드 블록만 있음**: 정상 작동 (코드 블록은 번역 제외)
3. **EN에서 모든 이미지 삭제 후 업데이트**: 경로 기반 매칭으로 안전하게 처리
4. **매우 긴 포스트 (1000+ 세그먼트)**: chunking + 병렬 처리로 성능 확보
5. **EN 구조가 KO와 완전히 다름**: 409 에러 + rebase 옵션 제시

---

원하면, 이 명세서 그대로 **“Cursor 작업 단위(체크리스트) + 각 파일의 함수 시그니처/타입 + 에러 케이스(409/400)까지 포함한 v1 구현 템플릿”**로 더 쪼개서, Cursor가 거의 자동으로 PR 만들 수 있게도 정리해줄게.
