According to a document from **2025-12-25**, 현재 USLab의 히트맵은 **외부 라이브러리 없이(순수 Canvas + Next.js API + Supabase)**로 이미 잘 동작하는 MVP가 있고, 구조도 “이식(shadcn 스타일)”에 맞게 잘 짜여 있습니다. 이 기반을 유지하면서 **Beusable급(부드럽게 번지는 Blob 히트맵)**으로 올리는 **Cursor 투입용 명세서**를 아래처럼 정리합니다. 

---

# USLab Heatmap v2 명세서 (Beusable급 Blob / No Session Replay / No External Lib)

## 0) 목적과 범위

### 목표

1. **스크롤/긴 페이지에서도 정확한 좌표**로 클릭 분포를 재현한다.
2. 기존 “20×20 그리드 fillRect” 방식 대신, **Blur 누적 + Colorize(팔레트 매핑)**로 “번지는 히트맵”을 구현한다.
3. **외부 오픈소스 히트맵 라이브러리 없이** 구현한다(번들/의존성 최소화). 
4. Supabase/Vercel 환경에서 운영 가능하도록 **서버 집계(bin)**를 유지한다(전송량/렌더 부하 제어). 

### Non-goals (이번 작업에서 하지 않음)

* ✅ **세션 녹화(Session Recording) 구현하지 않음**
* rrweb, DOM recording, 재생 플레이어, 스토리지 설계 전부 제외

---

## 1) 현행 구조(참고) — 변경은 “최소 침습” 원칙

현재 파이프라인은 아래 흐름입니다. 유지합니다. 

* `components/analytics/Tracker.tsx`에서 클릭을 capture phase로 수집
* `lib/utils/eventTracker.ts`의 `trackClick()`이 좌표 정규화 후 EventQueue에 enqueue
* `POST /api/track`가 `uslab_events.props`에 저장
* `GET /api/admin/heatmap/[pagePath]`가 click events 조회 후 **20×20 grid**로 집계
* `components/admin/HeatmapViewer.tsx`가 fetch
* `components/admin/HeatmapOverlay.tsx`가 Canvas로 렌더(fillRect)

특히, 현재 `trackClick()`은 `x = clientX / innerWidth`, `y = clientY / innerHeight` **(뷰포트 기준 정규화)**를 저장합니다. 
그리고 서버는 그 `x,y`를 20×20으로 binning 합니다. 

---

## 2) Heatmap v2 핵심 변경점 요약

### A. 수집 데이터에 “문서 기준 좌표” 추가

* 기존 viewport 기준 `x,y`는 유지(호환성/디버깅)
* **신규** `page_x, page_y` 추가(스크롤 포함된 문서 좌표 정규화)

### B. 서버 집계를 20 → **200(기본)** 수준으로 고해상도 binning

* 예: `gridSize=200` (40,000셀)
* 실제로는 “클릭이 있는 bin만” 반환하므로 payload는 작음

### C. 렌더링을 fillRect → **Blur 누적 + Colorize**

* offscreen(shadow) canvas에 점들을 blur로 누적(알파 누적)
* 누적 알파를 팔레트로 매핑하여 색상을 입힘(blue→green→yellow→red)

### D. 오버레이 캔버스를 “문서 전체 크기” → **뷰포트 고정 캔버스**로 전환

현재는 문서 전체 크기로 캔버스를 만들고 있습니다. 
v2에서는 캔버스를 `100vw × 100vh (fixed)`로 고정하고, 스크롤에 따라 좌표를 화면으로 변환해 다시 그립니다. (메모리/CPU 안정화)

---

## 3) 구현 작업 목록(= Cursor TODO)

### 3.1 클라이언트 수집 변경: `trackClick()` 확장

**파일**: `lib/utils/eventTracker.ts` 

#### (1) 기존 필터는 유지

* INPUT/TEXTAREA/contentEditable 제외(개인정보 보호) 
* `data-analytics-ignore` 제외 

#### (2) 신규 props 추가(문서 기준 좌표)

아래 키를 `props`에 추가 저장:

* `page_x`: number (0~1)

  * `(event.clientX + window.scrollX) / docWidth`
* `page_y`: number (0~1)

  * `(event.clientY + window.scrollY) / docHeight`
* `doc_w`: number

  * `Math.max(documentElement.scrollWidth, body.scrollWidth, innerWidth)`
* `doc_h`: number

  * `Math.max(documentElement.scrollHeight, body.scrollHeight, innerHeight)`
* `scroll_x`, `scroll_y`: number (디버깅/분석용)
* `device_bucket`: `'mobile'|'desktop'` (간단 분리, 예: `innerWidth < 768`이면 mobile)
* (선택) `client_ts`: 이미 이벤트 스키마에 존재하므로 가능하면 채워 넣기(기존도 지원) 

> 참고: 현재 `props` 예시는 `x,y,viewport_w/h,element_id...`만 저장합니다. 여기에 키만 추가하면 됩니다. 

#### (3) 관리자 히트맵 모드에서는 클릭 수집 제외(오염 방지)

* URL에 `?heatmap=true`가 있으면 `trackClick`에서 early return
  (현재 히트맵은 `?heatmap=true`로 활성화합니다. )

---

### 3.2 서버 집계 API v2: binning 고해상도 + 신규 좌표 사용

**파일**: `app/api/admin/heatmap/[pagePath]/route.ts` 

현재는:

* `uslab_events`에서 `name='click'`, `page_path=...`, `created_at>=...`
* `props.x/y`로 20×20 grid 집계 

#### 변경 요구사항

1. 기본 gridSize를 **200**으로 변경 (query param으로 조절 가능)
2. 좌표는 우선순위로 사용:

* 1순위: `props.page_x`, `props.page_y`
* 2순위(레거시): `props.x`, `props.y`

3. query param 확장

* `days`: number (기존 유지, default 30) 
* `grid`: number (default 200, 최소 50~최대 400 같은 guard)
* `device`: `all | mobile | desktop` (default all)

  * `props.device_bucket`으로 필터(서버에서 필터)

4. 응답 스키마 변경(하위호환 유지)

* 기존 `grid: Record<string, number>`는 유지(키 `"gx,gy" -> count`)
* `stats`에 v2 정보 추가

**Response (권장)**

```ts
type HeatmapResponseV2 = {
  grid: Record<string, number>; // "gx,gy": count (gx,gy는 0..gridSize-1)
  stats: {
    totalClicks: number;
    maxClicks: number;
    gridSize: number;
    dateRange: { start: string; end: string };
    coordMode: "page" | "legacy";
    filteredBy: { device: "all" | "mobile" | "desktop" };
  };
  // (선택) AI 요약용
  summary?: {
    topHotspots: Array<{ gx: number; gy: number; count: number }>; // 상위 10
    topElements?: Array<{ element_id: string; count: number }>;    // 상위 10 (가능하면)
  };
}
```

> 기존 구현도 `grid`와 `stats.totalClicks/gridSize/dateRange`를 반환합니다. 이 형태는 유지하되 확장합니다. 

#### 성능 가드(필수)

* `gridSize` 범위 제한(예: 50~400)
* 이벤트가 너무 많을 때(예: 100k 이상 추정) **샘플링 or 기간 축소 경고**를 stats에 포함

  * (간단 버전) 서버 집계는 그대로 하되, fetch rows가 너무 크면 `days`를 줄이도록 UI에서 안내

---

### 3.3 HeatmapViewer 수정: 필터/옵션 전달 + v2 타입 반영

**파일**: `components/admin/HeatmapViewer.tsx` 

현재:

* `?heatmap=true`일 때 `/api/admin/heatmap/${pagePath}?days=30` 호출
* bearer 토큰으로 인증
* `grid/gridSize/totalClicks`만 state로 관리 

#### 변경 요구사항

1. UI에 최소 옵션 추가

* days(7/30) 드롭다운(또는 현재 유지)
* device filter(all/mobile/desktop)
* gridSize(기본 200 / 선택적으로 100,200,300)

2. fetch URL에 query 반영

* `/api/admin/heatmap/${encodedPath}?days=30&grid=200&device=all`

3. `HeatmapOverlay`에 v2 데이터를 전달

---

### 3.4 HeatmapOverlay v2: Blob 렌더러로 교체 + viewport canvas

**현행**: 문서 전체 크기로 docSize 추적 → 캔버스도 문서 크기로 생성 → grid cell을 fillRect로 칠함 

#### 변경 요구사항 (핵심)

##### (1) 오버레이 레이아웃 유지, 캔버스만 “뷰포트 고정”으로 전환

* `div`/`canvas`는 `fixed top-0 left-0 w-screen h-screen pointer-events-none`
* 컨트롤 패널은 기존처럼 `pointer-events-auto` 유지 (현재 구조가 이미 그렇게 되어 있음) 

##### (2) 좌표 변환

서버에서 오는 bin(gx,gy)을 점 중심으로 환산:

* 문서 기준 좌표(0~1):

  * `nx = (gx + 0.5) / gridSize`
  * `ny = (gy + 0.5) / gridSize`
* 문서 픽셀 좌표(현재 렌더 시점의 docW/docH):

  * `docX = nx * docW`
  * `docY = ny * docH`
* 현재 화면 좌표:

  * `screenX = docX - scrollX`
  * `screenY = docY - scrollY`

> docW/docH는 렌더 시점에 계산(기존의 updateDocSize 로직을 재사용하되, 캔버스 크기로 쓰지 말고 “변환용”으로만 사용) 

##### (3) 렌더 알고리즘 (Blur 누적 + Colorize)

**외부 라이브러리 없이 Canvas만 사용** (현재도 그 원칙을 채택 중) 

구현 포인트:

* 메인 캔버스 1개 + offscreen canvas 1개(shadow)
* stamp canvas(원형 그라데이션) 1개를 미리 만들어서 `drawImage`로 빠르게 누적
* 누적 후 `getImageData`로 alpha를 읽고 팔레트로 색칠해서 메인에 출력

**설정값(컨트롤 패널에서 조절 가능하게)**

* `radiusPx`: 기본 35
* `blurPx`: 기본 25
* `opacity`: 기본 0.65
* `maxAlphaClamp`: 기본 220 (너무 진해지는 것 방지)

**팔레트(권장)**

* 0.0 blue → 0.25 cyan → 0.5 green → 0.75 yellow → 1.0 red
  (기존 v1도 파랑/초록/노랑/빨강 단계를 쓰고 있음. v2는 이를 연속 팔레트로 확장) 

##### (4) 리렌더 트리거(필수)

* scroll/resize 시 requestAnimationFrame으로 throttle하여 재렌더
* radius/blur/opacity 변경 시 stamp 재생성 + 재렌더
* docSize 변경(이미지 로딩 등) 시 재렌더 (ResizeObserver 유지 가능) 

##### (5) 성능 가드

* 화면 밖 포인트는 skip

  * `if (screenX < -R || screenX > vw + R) continue;`
* 포인트 수가 너무 많으면(예: > 20,000 bins) 경고 표시 + radius 증가 제한 등(선택)

---

## 4) DB / 마이그레이션 정책

### 필수 DB 변경: 없음

* `uslab_events.props`가 JSONB라서, **키만 추가 저장하면 됨** 

### (선택) DB-side 집계(RPC) — 트래픽 커지면 추천

현재 서버는 `select('props')`로 전부 가져와서 JS에서 집계합니다. 
트래픽이 커지면 Supabase 1000행 제한/페이지네이션 같은 이슈가 생길 수 있으니(이미 다른 쿼리에서 경험함), 향후 아래 RPC를 고려:

* `uslab_get_heatmap_bins(page_path, start_ts, grid_size, device)`
* Postgres에서 `floor((props->>'page_x')::float * grid_size)`로 group by

> 이번 스펙에서는 **우선 Next.js API에서 집계 유지**(최소 변경).
> 단, 성능 이슈가 보이면 RPC로 전환할 수 있게 API 레이어는 v2 스키마로 고정해두기.

---

## 5) AI 연동(이번 작업 범위 내: “요약 데이터 생성”까지만)

AI 보고서에서 행동 분석을 강화하려면 “히트맵 원본”보다 **요약값**이 훨씬 효율적입니다. (AI 보고서 명세에서도 “구조화된 데이터 제공”을 권장) 

따라서 `/api/admin/heatmap/[pagePath]` 응답에 `summary`를 옵션으로 포함:

* `topHotspots`: 상위 10개 bin
* `topElements`: element_id 상위 10개(가능하면 API에서 함께 집계)

  * element 집계는 `props.element_id`를 카운트하면 됨(현행에도 element_id 저장) 

이 `summary`는 차후 `/api/ai/analytics-report` 프롬프트에 그대로 포함 가능.

---

## 6) 수용 기준(Acceptance Criteria)

### 기능 정확성

1. 긴 페이지에서 아래로 스크롤한 뒤 클릭 → 저장된 `page_y`로 인해 **해당 섹션으로 스크롤했을 때 핫스팟이 정확히 따라다닌다.**
2. `?heatmap=true` 모드에서 overlay가 페이지 인터랙션을 막지 않는다.

   * overlay: `pointer-events-none`
   * 컨트롤 패널: `pointer-events-auto` 

### 시각 품질

3. 기존 v1 “격자(fillRect)” 느낌이 아니라, **점들이 겹치며 덩어리(Blob)**가 형성되는 히트맵이 표시된다.

### 성능

4. 스크롤/리사이즈 중에도 UI가 버벅이지 않는다(rAF throttle 필수).
5. 데이터 fetch는 기존처럼 관리자 인증 토큰 기반으로 동작한다. 

---

## 7) 테스트 플랜(수동)

1. 관리자 로그인
2. 메인 페이지에 일반 모드로 들어가 클릭 몇 번 수행(상단/중단/하단)
3. `/ko?heatmap=true`로 진입
4. days=7, grid=200, device=all에서 히트맵 확인
5. 페이지를 스크롤하면서 “핫스팟이 해당 섹션에 붙어 있는지” 확인
6. device=mobile/desktop 필터 변경 시 결과가 달라지는지 확인

---

## 8) Cursor에 바로 던질 실행 지시문(복붙용)

아래를 Cursor에 그대로 던지면 됩니다.

> **[TASK] USLab Heatmap v2 (Blob Heatmap, No Session Replay, No External Lib)**
>
> * 현재 히트맵 구조(Tracker.tsx → eventTracker.ts → /api/track → uslab_events → /api/admin/heatmap/[pagePath] → HeatmapViewer → HeatmapOverlay)를 유지하되, v2로 업그레이드한다.
> * `lib/utils/eventTracker.ts`의 `trackClick()`에 `page_x/page_y/doc_w/doc_h/scroll_x/scroll_y/device_bucket`를 `props`에 추가 저장한다. 기존 `x/y/viewport_w/h/element_id`는 유지한다. INPUT/TEXTAREA/contentEditable 및 `data-analytics-ignore` 필터는 그대로 유지한다. 또한 `?heatmap=true` 모드에서는 클릭 수집을 하지 않는다.
> * `app/api/admin/heatmap/[pagePath]/route.ts`에서 gridSize 기본값을 200으로 하고(`grid` query param 허용), 집계는 `props.page_x/page_y`를 우선 사용하며 없으면 `props.x/y`로 fallback 한다. `device` query param(all/mobile/desktop)도 지원한다. 응답은 `grid: Record<string, number>`(키는 “gx,gy”)와 `stats(totalClicks,maxClicks,gridSize,dateRange,coordMode,filteredBy)`를 반환한다.
> * `components/admin/HeatmapViewer.tsx`는 v2 응답 타입을 반영하고, days/grid/device 옵션을 추가하여 API 호출에 포함한다.
> * `components/admin/HeatmapOverlay.tsx`는 “문서 전체 크기 캔버스 + fillRect 그리드”를 제거하고, “뷰포트 고정 캔버스 + Blur 누적 + Colorize” Blob 히트맵 렌더러로 교체한다. overlay는 pointer-events-none 유지, 컨트롤 패널은 pointer-events-auto 유지. scroll/resize는 requestAnimationFrame throttle로 재렌더한다.
> * 외부 heatmap 라이브러리(heatmap.js 등) 추가 금지. 세션녹화 구현 금지.
> * 완료 후 수동 테스트 시나리오(스크롤 페이지에서 핫스팟 정렬 확인)를 통과해야 한다.

---

원하시면, 위 명세를 그대로 따라 **“API 응답 스키마(v2) + Overlay 렌더러(Blob) 구현 코드 골격”**까지도 Cursor 프롬프트용으로 더 세분화해서(파일별 코드 블록 단위로) 만들어드릴게요.
