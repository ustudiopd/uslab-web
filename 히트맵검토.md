지금 USLab에 붙어있는 히트맵은 **“MVP로는 충분히 좋은 구조”**예요.
클릭을 `uslab_events`에 쌓고 → 서버에서 20×20 그리드로 집계 → Canvas에 `fillRect`로 칠하는 방식이라, 구현/운영이 가볍고 이식성도 좋습니다. 

다만, 지금 상태로는 질문에 올린 Beusable 예시처럼 **부드럽게 번지는(Blob/Gaussian) 히트맵** 느낌이 나오기 어렵습니다. “상용 히트맵 느낌”으로 가려면 아래 2가지를 꼭 바꿔야 해요.

---

## 1) 지금 구현이 “Beusable 느낌”이 안 나는 핵심 이유 2가지

### (A) 좌표가 “뷰포트 기준”이라 긴 페이지/스크롤에서 왜곡

현재는 `x = clientX / innerWidth`, `y = clientY / innerHeight`로 저장하고 있어요. 
이 값은 **“화면에서의 위치”**라서, 사용자가 아래로 스크롤한 상태에서 클릭해도 `y`는 다시 0~1로 들어가요.

그런데 렌더링은 문서 전체 높이(`scrollHeight`) 기준으로 캔버스를 깔고 있어서(문서 전체 히트맵을 의도), 스크롤이 있는 페이지에서는 “정확한 위치에 찍힌 히트맵”이 되기 어렵습니다. 

✅ 해결: **문서 기준 좌표(page_x/page_y)** 또는 **요소 기준 좌표(element_x/element_y)**를 저장해야 합니다.

---

### (B) 20×20 그리드는 “블록맵”이지 “히트맵(커널 밀도)”이 아님

상용 히트맵은 보통 **점(클릭)을 중심으로 반경(radius) + 블러(blur)**를 주고, 점들이 겹치면 강도가 쌓이면서 **부드러운 덩어리(Blob)**가 생깁니다.

지금은 각 셀을 네모로 칠하니, 아무리 색을 잘 잡아도 “격자 느낌”이 나요. 

✅ 해결: 렌더링을 **KDE(커널 밀도) 방식**으로 바꾸면 이미지처럼 나옵니다.

---

## 2) “Beusable 수준”으로 가는 Heatmap v2 설계 제안

### 목표

* **정확한 좌표**(스크롤 포함)로 저장
* **부드러운 Blob 렌더링**(radius+blur+colorize)
* 데이터량이 늘어도 **Supabase + Vercel에서 충분히 운영 가능한 구조**
* AI 분석에 바로 쓰일 수 있는 **요약 지표**도 함께 뽑기

---

## 3) 수집(클라이언트) 변경안: `trackClick`에 최소 6개 필드 추가

지금 `props`가 JSONB라서 “DB 마이그레이션 없이” 키만 추가하면 됩니다. 

### (1) 문서 기준 정규화 좌표 추가 (핵심)

* `page_x`: (clientX + scrollX) / docWidth
* `page_y`: (clientY + scrollY) / docHeight
* `doc_w`, `doc_h`: 클릭 당시 문서 크기 (디버깅/보정용)
* `scroll_x`, `scroll_y`: 클릭 당시 스크롤 (디버깅/추후 분석용)

이렇게 하면 **스크롤 위치에 상관없이 페이지 전체에서의 위치**를 복원할 수 있어요.

### (2) 요소 기준 좌표도 같이 저장 (강추)

상용 히트맵은 “페이지 좌표”만 쓰면 반응형에서 위치가 어긋날 때가 많습니다.
USLab은 Next.js라서 레이아웃이 바뀌기 쉬우니, 아래도 같이 저장하는 게 좋아요.

* `element_id`: 지금처럼 `data-analytics-id`
* `element_x`, `element_y`: 요소 내부 좌표(0~1)
* `element_w`, `element_h`: 요소 크기(선택)

> 이걸 넣어두면 “요소가 움직여도” 히트맵이 그 요소에 붙는 방식으로 렌더링할 수 있습니다.
> (page_x/y로 안 맞을 때 fallback로 element 기준으로 그리기)

### (3) 개인정보/민감정보는 그대로 회피

현재 INPUT/TEXTAREA 제외, `data-analytics-ignore` 제외는 잘 되어 있어요. 
Beusable급으로 간다고 해서 **텍스트/DOM을 저장할 필요는 없습니다.** (세션녹화 안 하는 방향과도 맞음)

---

## 4) 조회/집계(서버) 변경안: “고해상도 bin + 가우시안 렌더링” 조합

### 권장 옵션 2가지 (트래픽 1,000/day 기준)

#### 옵션 A) raw point를 그대로 내려주고 클라이언트에서 렌더

* 장점: 구현 단순, 정확도 최고
* 단점: 30일 누적이 많아지면 payload가 커짐

**1,000/day에서 클릭 이벤트가 아주 많지 않다면**(예: 평균 3~10 클릭/세션)도 충분히 가능.

#### 옵션 B) 서버에서 binning 해서 내려주기 (추천)

현재 20×20을 **200×200 또는 300×300** 정도로 올립니다.

* 서버: bins를 만들어 `{gx, gy, count}`만 내려줌
* 클라: 각 bin의 중심점을 “가중치 count”로 찍어서 Blob 렌더링

이 방식은 데이터가 커져도 “항상 일정한 크기의 결과”를 주기 때문에 운영이 편합니다.

> 지금 방식(20×20)은 너무 거칠어서 “상용 느낌”이 안 나지만,
> 200×200 + Blob 렌더링이면 체감이 확 달라집니다.

---

## 5) 렌더링(클라이언트) 변경안: “heatmap.js 스타일” 알고리즘을 내부 이식

Beusable 같은 히트맵의 정석 알고리즘은 보통 이런 흐름입니다.

1. **shadow canvas**에 점을 “검정색 + blur circle”로 누적 (alpha에 강도가 쌓임)
2. shadow의 픽셀 `alpha(0~255)`를 읽어서
3. `alpha → 팔레트(파랑~빨강)`로 색칠(colorize)
4. 결과를 실제 canvas에 출력

이 방식은 외부 라이브러리 없이도 구현 가능하고, 지금 “shadcn처럼 이식” 철학에도 잘 맞아요. 

### 렌더링을 “문서 전체 캔버스”로 하지 말고 “뷰포트 캔버스”로

지금은 문서 높이만큼 캔버스를 크게 만들고 있어요. 
이건 페이지가 길어질수록 캔버스 픽셀이 폭증(메모리/CPU 증가)합니다.

**추천 방식:**

* 캔버스는 **viewport 크기**로만 유지 (`position: fixed; width: 100vw; height: 100vh`)
* 렌더링할 때만 `page_x/y → 현재 스크롤 기준 화면 좌표`로 변환해서 그리기

변환식:

* `px = page_x * currentDocW - scrollX`
* `py = page_y * currentDocH - scrollY`

이러면 스크롤해도 히트맵이 정확히 따라오고, 캔버스가 커지지 않습니다.

### 컨트롤(패널)에서 “radius/blur/opacity” 조절 가능하게

Beusable류 도구 느낌은 사실 “렌더 옵션”이 50%를 결정합니다.

* radius(예: 25~60px)
* blur(예: 15~40px)
* opacity(예: 0.4~0.9)
* gradient preset(blue→green→yellow→red)

이걸 패널에서 바꾸면서 “가독성이 가장 좋은 설정”을 찾을 수 있어요.

---

## 6) “상용 수준”에 가까워지게 해주는 추가 기능 3가지

히트맵만으로도 UX 분석은 꽤 깊게 갑니다. 특히 세션녹화를 안 할수록 아래가 중요해요.

### (1) Dead Click / Rage Click 추정

세션녹화 없이도 충분히 “문제 지점”을 잡을 수 있습니다.

* **Dead Click(추정)**: `href_host=null`이고 `element_tag`가 button/a가 아닌데 클릭이 높은 영역
  → “클릭 가능한 줄 알고 누르는 곳”
* **Rage Click**: 같은 `session_id + page_path`에서 짧은 시간(예: 2초)에 비슷한 좌표 반복
  → “안 눌려서 빡쳐서 연타하는 곳”

현재 `client_ts`를 이미 저장하니(옵션이지만) 이건 추가 집계만 하면 됩니다. 

### (2) 디바이스별 히트맵 분리(필수급)

데스크톱/모바일은 레이아웃이 달라서 “한 장의 히트맵”으로 섞으면 오해가 생깁니다.

* `device_type`(이미 세션에 있음)을 기준으로 필터링 UI 제공
* 또는 `viewport_w` 기반으로 bucket(모바일/태블릿/데스크탑)을 나눔 

### (3) 스크롤맵(Scroll map)은 “세션녹화 없이” 가능한 최상급 대안

세션녹화 대신 “스크롤 깊이”만 잘 해도, 상당히 많은 인사이트가 나옵니다.

* “CTA가 70% 지점에 있는데 평균 스크롤이 45%면 CTA를 못 본다”
* “긴 글인데 20%에서 대부분 이탈한다 → 첫 1~2단 구성 바꿔라”

USLab은 이미 `scroll_depth`, `page_engagement` 이벤트 구조가 있으니 연결이 좋습니다. (AI 보고서 명세에도 있음)

---

## 7) AI 기능과 히트맵을 “바로 연결”하는 방법

AI가 히트맵을 잘 분석하게 하려면 “이미지”를 넘기기보다 **구조화된 요약값**을 만들어 넣는 게 훨씬 효율적입니다.

### AI 입력으로 넣을 만한 히트맵 요약 스키마 예시

* 페이지별

  * `total_clicks`
  * `top_hotspots`: (x,y,count) 상위 5~10개 (bin 기반)
  * `top_elements`: `data-analytics-id` 상위 10개
  * `dead_click_zones`: dead click 추정 hotspot 상위 5개
  * `rage_click_elements`: rage click 의심 element 상위 5개
  * `click_concentration`: 상위 10% 영역이 전체 클릭의 몇 %를 먹는지(집중도)

이걸 AI 보고서 프롬프트에 넣으면,

* “어디가 핫한지”를 넘어
* “왜 거기서 문제가 생기는지”까지 액션으로 뽑아낼 확률이 확 올라갑니다.

---

## 8) 적용 우선순위 제안

지금 코드/구조를 최대한 살리면서 “체감 업그레이드”가 큰 순서로:

1. **좌표를 page 기준으로 확장** (`page_x/page_y`, `doc_w/doc_h`, `scroll_y`)
2. **뷰포트 캔버스 + scroll offset 렌더**로 정렬 문제 해결
3. **20×20 → 200×200 bin + Blob 렌더링** (Beusable 느낌의 핵심)
4. **디바이스 필터**(desktop/mobile)
5. Dead/Rage click 요약 + AI 보고서에 포함

---

## 결론

* 지금 구현은 “운영 가능한 MVP”로 아주 잘 잡혀 있고, 구조도 이식성 있게 잘 짜여 있어요. 
* Beusable급으로 보이게 만드는 핵심은
  **(1) 스크롤 포함한 page 좌표 저장** + **(2) KDE(blur circle + colorize) 렌더링** 두 가지입니다.
* 세션녹화를 하지 않는 방향이라면, 위 Heatmap v2 + ScrollMap + Dead/Rage click만으로도 **AI가 낼 수 있는 UX 개선안의 질이 꽤 상용급**까지 올라갑니다.

원하면, 지금 `HeatmapOverlay.tsx` 구조(컨트롤 패널 유지)를 그대로 두고
**“Blob 렌더러(순수 Canvas)”만 교체하는 형태로** 구체 코드(컴포넌트/유틸 단위)까지 바로 제안해줄게요.
